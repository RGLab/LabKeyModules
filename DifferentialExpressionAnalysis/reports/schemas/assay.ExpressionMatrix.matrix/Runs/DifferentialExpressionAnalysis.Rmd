```{r knitr_opts, echo = FALSE, cache = FALSE}
library(knitr)
opts_chunk$set(cache = FALSE, cache.path = file.path(labkey.file.root, "cache/DifferentialExpressionAnalysis/"))
opts_chunk$set(echo = FALSE, message = FALSE)
```

```{r libraries, message = FALSE, echo = FALSE, warning = FALSE}
library(dplyr)
library(Rlabkey)
library(ImmuneSpaceR)
library(limma)
library(Biobase)
library(data.table)
library(gtools)
library(DT)
```

```{r parameters}
contrast <- c("study_time_collected", "study_time_collected_unit")
study <- basename(labkey.url.path)
```

## Differential expression analysis

Returns genes differentially expressed with an FDR of less than 20%, or top 100 lowest FDR.

study: `r study`  
contrast: `r contrast`

```{r getData, warning = FALSE}
onTest <- labkey.url.base == "https://test.immunespace.org"
con <- CreateConnection(study, onTest = onTest)

if (is.null(con$cache[["GE_matrices"]])) {
  warning("There is no HIPCMatrix run in this study")
  opts_chunk$set(eval = FALSE, echo = FALSE)
}

# create df of cohorts and timepoints
con$getGEInputs()

coefs<- unique(con$cache$GE_inputs[, c("arm_name", contrast), with = FALSE])
if( !any(coefs$study_time_collected <= 0) ){
  stop("No baseline timepoints available in any cohort. Analysis not run.")
}

if( sum(coefs$study_time_collected > 0) == 0 ){
  stop("No post-baseline timepoints available in any cohort. Analysis not run.")
}

tmp <- coefs %>%
  group_by(arm_name) %>%
  mutate(baseline = any(study_time_collected <= 0)) %>%
  filter(baseline == TRUE) %>%
  mutate(laterTp = sum(study_time_collected > 0 )) %>%
  summarize(tps = unique(laterTp))

message(paste("There will be", 
              sum(tmp$tps), 
              "differential expression analysis."))
```

```{r analysis}
idx <- 1

GEA_list <- vector("list")
GEAR_list <- vector("list")

cm <- con$getDataset("cohort_membership")
cm <- unique(cm[, list(cohort, arm_accession)])

runs <- con$cache$GE_matrices[, list(cohort, name)]
setnames(runs, "cohort", "arm_name")

for (mx in runs$name) {

  EM <- con$getGEMatrix(matrixName = mx)
  pd <- data.table(pData(EM))
  pd <- pd[, coef := do.call(paste, .SD), .SDcols = contrast]
  to_drop <- unique(pd[study_time_collected <= 0, coef])
  if( length(to_drop) == 0 ){
      message(paste0("No baseline for ", mx, ". Skipping to next EM."))
      next()
  }
  pd <- pd[coef %in% to_drop, coef := "baseline"]
  tmp <- grep("baseline", value = TRUE, invert = TRUE, mixedsort(unique(pd$coef)))
  pd <- pd[, coef := factor(coef, levels = c("baseline", tmp))] # preps coef col for use in model
  mm <- model.matrix(formula("~participant_id + coef"), pd)
  
  if(dim(mm)[[1]] > dim(mm)[[2]]){
    # Check if it's non-normalized and use na.rm = T b/c currently allowing NAs to remain
    # in matrices in pipeline unless normalization doesn't work (e.g. DEseq)
    if (max(exprs(EM), na.rm = TRUE) > 100) { EM <- voom(EM) }
    fit <- lmFit(EM, mm)
    fit <- tryCatch(
            eBayes(fit),
            error = function(e) return(e)
         )   
  
    if( !is.null(fit$message) ){  
      message(paste0("Linear model not able to be fit for ", mx, ". Skipping to next matrix"))
      next() 
    }   
  
    timepoints <- grep("^coef", colnames(mm), value = TRUE)
    for (tp in timepoints) {
      tt <- data.table(topTable(fit, coef = tp, number = Inf))
      if(all(is.na(tt$adj.P.Val))){
        message(paste0(tp, " has all NA values for adj.P.Val. Skipping to next coef."))
        next()
      }
 
      analysis_accession <- paste0("GEA", idx )
      currTP <- gsub("coef", "", tp)
      arm_name <- unique(pd$cohort)
      arm_accession <- cm[ cohort == arm_name, arm_accession ]
      if (is.null(arm_name)){ arm_name <- NA }
      description <- paste0("Differential expression in ",
                            mx, ", ", currTP, " vs. baseline")
  
      GEA_list[[idx]] <- data.table(analysis_accession = analysis_accession,
                                    expression_matrix = mx,
                                    arm_name = arm_name,
                                    arm_accession = arm_accession,
                                    coefficient = currTP,
                                    description = description)
  
      ttDE <- tt[adj.P.Val < 0.02]
  
      if (nrow(ttDE) < 100) {
        ttDE <- tt[order(adj.P.Val)][1:min(nrow(tt), 100)]
      }
  
      if (nrow(ttDE) > 0) {
        ttDE[, c("analysis_accession", "coefficient") := list(analysis_accession, currTP)]
        GEAR_list[[idx]] <- data.table(ttDE)
      }
  
      idx <- idx + 1
    }
  }else{
    message("Run ", mx, "does not have enough subjects to perform analysis.")
  }
}
GEA <- rbindlist(GEA_list)

if (length(GEAR_list) == 0) {
  warning("No feature was found to be differentially expressed at any timepoint.")
  opts_chunk$set(eval = FALSE, echo = FALSE)
} else {
  GEAR <- rbindlist(GEAR_list)
  setnames(GEAR,
           c("FeatureId", "gene_symbol", "adj.P.Val", "AveExpr", "logFC", "P.Value", "t"),
           c("feature_id", "gene_symbol", "adj_p_val", "ave_expr", "log_fc", "p_value", "statistic"))
}
```

```{r write}

if( length(GEA_list) > 0 ){
    # Set HTTP call vars
    baseUrl <- labkey.url.base
    folderPath <- labkey.url.path
    schemaGE <- "gene_expression"
    queryGEA <- "gene_expression_analysis"
    queryRes <- "gene_expression_analysis_results"

    # delete old GEA
    currGEA <- labkey.selectRows(baseUrl = baseUrl,
                                 folderPath = folderPath,
                                 schemaName = schemaGE,
                                 queryName = queryGEA,
                                 colNameOpt = "rname",
                                 showHidden = T)
    if( nrow(currGEA) != 0 ){
      deleteGEA <- labkey.deleteRows(baseUrl = baseUrl,
                                     folderPath = folderPath,
                                     schemaName = schemaGE,
                                     queryName = queryGEA,
                                     toDelete = currGEA)
      if( deleteGEA$rowsAffected != nrow(currGEA) ){
        stop("currGEA not deleted correctly")
      }
    }

    # push newGEA b/c listings may be different in terms of idx than old
    newGEA <- rbindlist(GEA_list)
    doneGEA <- labkey.importRows(baseUrl = baseUrl,
                                 folderPath = folderPath,
                                 schemaName = schemaGE,
                                 queryName = queryGEA,
                                 toImport = newGEA)

    if( doneGEA$rowsAffected != nrow(newGEA) ){
      stop("newGEA not imported correctly")
    }

    # GEAR gets deleted and then new rows imported because
    # new mappings will be different and do not want to have leftovers
    if(length(GEAR_list) != 0){
      currGEAR <- labkey.selectRows(baseUrl = baseUrl,
                                    folderPath = folderPath,
                                    schemaName = schemaGE,
                                    queryName = queryRes,
                                    colNameOpt = "rname",
                                    showHidden = T)

      if( nrow(currGEAR) != 0 ){
        delGEAR <- labkey.deleteRows(baseUrl = baseUrl,
                                     folderPath = folderPath,
                                     schemaName = schemaGE,
                                     queryName = queryRes,
                                     toDelete = currGEAR)

        suppressWarnings(postDeleteGEAR <- labkey.selectRows(baseUrl = baseUrl,
                                            folderPath = folderPath,
                                            schemaName = schemaGE,
                                            queryName = queryRes,
                                            colNameOpt = "rname",
                                            showHidden = T))

        if( nrow(postDeleteGEAR) != 0){
          stop("not all GEAR deleted correctly")
        }
      }

      # Import new GEAR
      GEAR <- rbindlist(GEAR_list)
      GEAR[ is.na(GEAR) ] <- ""
      setnames(GEAR,
               c("FeatureId", "gene_symbol", "adj.P.Val", "AveExpr", "logFC", "P.Value", "t"),
               c("feature_id", "gene_symbol", "adj_p_val", "ave_expr", "log_fc", "p_value", "statistic"))
      toImport <- data.frame(GEAR, stringsAsFactors = F)
      resGEAR <- labkey.importRows(baseUrl = baseUrl,
                                   folderPath = folderPath,
                                   schemaName = schemaGE,
                                   queryName = queryRes,
                                   toImport = toImport)
    }
}
```

```{r new-analysis}
datatable(GEA)
```

```{r staticRender, results='asis'}
cat("<script>window.HTMLWidgets.staticRender();</script>")
```

