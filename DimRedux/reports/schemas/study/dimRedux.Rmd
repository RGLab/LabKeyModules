```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(ImmuneSpaceR)
library(dplyr)
library(tidyr)
library(data.table)
library(plotly)
```

```{r params}
  # Main Params
  sdy <- gsub("/Studies/", "", labkey.url.params$folderPath)
  timeAs <- labkey.url.params$timeAs
  assays <- strsplit(labkey.url.params$assays, ",")[[1]]
  timePts <- strsplit(labkey.url.params$timePts, ",")[[1]]
  label <- labkey.url.params$label
  plotType <- labkey.url.params$plotType

  # additional options
  perplexity <- as.integer(labkey.url.params$perplexity)
  numComponents <- as.integer(labkey.url.params$numComponents)
  impute <- labkey.url.params$impute
```

```{r helper-fn}
getAssayData <- function(assay, con, timePts, timeAs){
  if(assay != "gene_expression"){
    dat <- con$getDataset(assay, original_view = TRUE, transform.method = "auto")
  }else{
    eset <- con$getGEMatrix(con$cache$GE_matrices$name)
    dat <- data.frame(t(Biobase::exprs(eset)),stringsAsFactors = F)
    gef <- con$getDataset("gene_expression_files", original_view = T)
    ptid <- gef$participant_id[ match(rownames(dat), gef$biosample_accession) ]
    dat$study_time_collected <- gef$study_time_collected[ match(rownames(dat), gef$biosample_accession)]
    dat$study_time_collected_unit <- gef$study_time_collected_unit[ match(rownames(dat), gef$biosample_accession)]
    if(timeAs == "observation"){
      dat$sub_tp <- paste0( ptid, "_", dat$study_time_collected)
    }else{
      dat$participant_id <- ptid
    }
  }
  
  dat$stc_key <- paste(dat$study_time_collected, dat$study_time_collected_unit)
  dat <- dat[ dat$stc_key %in% timePts, ]

  if(nrow(dat) == 0){ return() } # Assay does not contain chosen timepoints

  if(assay == "hai"){
    dat <- dat %>%
        group_by_("participant_id", "study_time_collected") %>%
        mutate(avg = mean(value_reported)) %>%
        summarise(mean_hai = unique(avg))
    if(timeAs == "observation"){
      dat$sub_tp <- paste0( dat$participant_id, "_", dat$study_time_collected)
      dat <- dat[ , c("sub_tp", "mean_hai")]
    }else{
      dat <- spread(dat, key = "study_time_collected", value = "mean_hai")
      nms <- colnames(dat)[ colnames(dat) != "participant_id"  ]
      nms <- paste0(nms, "_mean_hai")
      colnames(dat) <- c("participant_id", nms)
    }
    
  }else if(assay == "fcs_analyzed_result"){
    if(timeAs == "observation"){ 
      dat$sub_tp <- paste0(dat$participant_id, "_", dat$study_time_collected)
      dat <- dat[ , c("sub_tp", "population_cell_number") ]
    }else{
      dat <- dat[ , c("participant_id", "population_cell_number"), with = FALSE]
    }
    
  }else if(assay == "elisa"){
    cols <- c("participant_id", "study_time_collected", "analyte", "value_preferred")
    dat <- dat[ , cols, with = FALSE ]
    if(timeAs == "observation"){
      dat <- dat %>% 
        mutate(sub_tp = paste0(participant_id, "_", study_time_collected)) %>%
        group_by(sub_tp, analyte) %>%
        summarize(newValue = unique(mean(value_preferred)))
      dat <- spread(dat, key = "analyte", value = "newValue")
    }else{
      dat <- dat %>%
        mutate(analyte_day = paste(analyte, study_time_collected, assay, sep = "_")) %>%
        group_by_("participant_id", "analyte_day") %>%
        summarise(newValue = unique(mean(value_preferred)))
      dat <- spread(dat, key = "analyte_day", value = "newValue")
    }
    
  }else if(assay == "elispot"){
    cols <- c("participant_id", "study_time_collected", "analyte", "spot_number_reported")
    dat <- dat[ , cols, with = FALSE ]
    if(timeAs == "observation"){
      dat <- dat %>% 
        mutate(sub_tp = paste0(participant_id, "_", study_time_collected)) %>%
        group_by(sub_tp, analyte) %>%
        summarize(newValue = unique(mean(spot_number_reported)))
      dat <- spread(dat, key = "analyte", value = "newValue")
    }else{
      dat <- dat %>%
        mutate(analyte_day = paste(analyte, study_time_collected, assay, sep = "_")) %>%
        group_by_("participant_id", "analyte_day") %>%
        summarise(newValue = unique(mean(spot_number_reported)))
      dat <- spread(dat, key = "analyte_day", value = "newValue")
    }

  }else if(assay == "gene_expression"){
    if(timeAs == "variable"){
      mats <- lapply(timePts, function(x){
        mat <- dat[ dat$stc_key == x, ]
        mat <- mat[, grep("stc_key|study_time_collected", colnames(dat), invert = T)]
        nms <- colnames(mat)[ colnames(mat) != "participant_id" ]
        nms <- paste0(nms, "_", gsub(" Days", "", x))
        colnames(mat) <- c(nms, "participant_id")
        return(mat)
      })
      dat <- Reduce(function(x,y){merge(x,y, by="participant_id", all=T)}, mats)
    }else{
      dat <- dat[, grep("stc_key|study_time_collected", colnames(dat), invert = T)]
    } 
  }

  return(data.frame(dat, stringsAsFactors = FALSE))
}
```

```{r prep-assay-data}
# Cache the allMat object on first run and then re-use for other labels
rdaPath <- paste0("/share/files/Studies/", sdy, "/@files/cache/DimensionReduction/", labkey.user.email)
if( !dir.exists(rdaPath) ){
    dir.create(rdaPath, recursive = TRUE)
}

# Need external count because array.forEach not predictable
if ( file.exists(paste0(rdaPath, "/iter.rda")) ){
    load(file = paste0(rdaPath, "/iter.rda"))
}else{
    iter <- 1
}

if (iter == 1){
    # ImmuneSpace connection
    onTest <- grepl("test", labkey.url.params$baseUrl)
    con <- CreateConnection(sdy, onTest = onTest)

    # get assay data
    aData <- lapply(assays,
                    getAssayData,
                    con = con,
                    timePts = timePts,
                    timeAs = timeAs)

    # Check aData to be sure non-null
    nulls <- sapply(aData, is.null)
    aData <- aData[ !nulls ]

    # Demo subs
    demo <- con$getDataset("demographics")

    # combine
    allMat <- Reduce(function(x,y){merge(x,y,all=T)}, aData)
    nmsCol <- grep("sub_tp|participant_id", colnames(allMat))
    rownames(allMat) <- allMat[, nmsCol]
    allMat <- allMat[,-nmsCol]

    # normalize
    allMat <- scale(allMat)

    # Impute missing values
    if(impute == "mean"){
        allMat <- apply(allMat, 2, function(x){ x[is.na(x)] <- mean(x, na.rm = T); return(x)})
    }else if(impute == "median"){
        allMat <- apply(allMat, 2, function(x){ x[is.na(x)] <- median(x, na.rm = T); return(x)})
    }else if(impute == "knn"){
        res <- impute::impute.knn(as.matrix(allMat))
        allMat <- res$data
    }else if(impute == "none"){
        allMat <- allMat[ complete.cases(allMat), ]
    }

    if(dim(allMat)[2] < 2){ 
        stop("R Report Error: Too few variables selected. Please select more assays or timepoints and re-run.")
    }else if(dim(allMat)[1] < 1){
        stop("R Report Error: No subjects with complete cases. Select imputation method other than 'None' and retry.")
    }
    save(demo, file = paste0(rdaPath, "/demo.rda"))
    save(allMat, file = paste0(rdaPath, "/allmat.rda"))
} else {
    load(file = paste0(rdaPath, "/demo.rda"))
    load(file = paste0(rdaPath, "/allmat.rda"))
}
```

### General Information
- Number of Observations (Subjects): `r dim(allMat)[1]`
- Number of Features (Assay Data): `r dim(allMat)[2]`

```{r prep-labels}
# Provide label vector
subs <- rownames(allMat)
if(label == "hai response"){
    if("hai" %in% assays){
      hai <- aData[[ grep("hai", assays) ]]
    }else{
      hai <- getAssayData("hai", con, timeAs = timeAs, timePts = timePts)
    }
    baseline <- grep("0_mean_hai", colnames(hai))
    laterDay <- max(colnames(hai)[ grep("mean_hai", colnames(hai))])
    hai$respCall <- ifelse(hai[[laterDay]]/ hai[[baseline]] > 4, "high", "low")
    subCol <- ifelse(timeAs == "observation", "sub_tp", "participant_id")
    hai <- hai[ hai[[subCol]] %in% subs, ]
    hai <- hai[ order(hai[[subCol]]), ]
    colorCol <- hai$respCall
}else if(label == "time"){
    colorCol <- gsub("^SUB\\d{5,6}\\.\\d{2,4}_", "", subs)
}else{
    if(timeAs == "observation"){ subs <- gsub("_\\d{1}", "", subs) }
    colorCol <- demo[[label]][ match(subs, demo$participant_id)]
}
```

### Plots
```{r  plot, fig.align="left"}
# Setup
prettyLbl <- tools::toTitleCase(gsub("_", " ", label))

# helper for iterating through multiple components of PCA 
makePlot <- function(i, j, resObj, type){
  if(type == "tSNE"){
    df <- data.frame(x = resObj$Y[,i],
                     y = resObj$Y[,j],
                     stringsAsFactors = FALSE)
  }else{
    df <- data.frame(x = pca$x[, paste0("PC",i)],
                     y = pca$x[, paste0("PC",j)],
                     stringsAsFactors = FALSE)
  }
  
  p <- plot_ly(data = df,
               x = ~x,
               y = ~y,
               color = colorCol,
               hoverinfo = 'text',
               text = paste(prettyLbl, ": ", colorCol, "<br>ID: ", rownames(allMat))) %>%
       layout(xaxis = list(title = paste0(type, i)), 
              yaxis = list(title = paste0(type, j)),
              annotations = list(yref = 'paper',
                                 xref = 'paper',
                                 y = 1.02,
                                 x = 1.175,
                                 text = prettyLbl,
                                 showarrow = FALSE),
              autosize = T,
              width = 700,
              showlegend=TRUE)
}

# create and sort possible component combinations
poss <- expand.grid(j = 1:numComponents, i = 1:numComponents)
poss <- poss[ poss$j != poss$i, ]
poss$test <- sapply(1:nrow(poss), function(x){
    paste(sort(c(poss[x,1], poss[x,2])), collapse = ":")
})
poss <- poss[ !duplicated(poss$test), ]

# Run analysis and get pieces together for plotting
if(plotType == "tSNE"){
  set.seed(8)
  # Avoid duplicate rows by adding random noise
  if( any(duplicated(allMat)) ){
    allMat[,1] <- jitter(allMat[,1], factor = 1, amount = NULL)
  }
  tRes <- Rtsne::Rtsne(allMat, dims = numComponents, perplexity = perplexity)
  moreArgs <- list(resObj = tRes, type = "tSNE")
}else{
  pca <- prcomp(allMat)
  moreArgs <- list(resObj = pca, type = "PCA")
}

plots <- mapply(makePlot,
                i = poss$i,
                j = poss$j,
                MoreArgs = moreArgs,
                SIMPLIFY = FALSE
                ) 
htmltools::tagList(plots)
```

```{r, cleanup}
if( (timeAs == "variable" & iter == 4) | (timeAs == "observation" & iter == 5) ){
    file.remove(paste0(rdaPath, "/demo.rda"))
    file.remove(paste0(rdaPath, "/allmat.rda"))
    file.remove(paste0(rdaPath, "/iter.rda"))
}else{
    iter <- iter + 1
    save(iter, file = paste0(rdaPath, "/iter.rda"))
}
```


<script>
window.HTMLWidgets.staticRender();
</script>

