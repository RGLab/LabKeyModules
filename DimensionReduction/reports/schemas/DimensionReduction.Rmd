---
output: html_document
---


<style>
  .tabset-dropdown > .nav-tabs > li.active:before {
    content: ">";
    display: inline-block;
    padding: 10px;
    border-right: 1px solid #ddd;
  }
                      
  .tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
    content: ">";
    border: none;
  }
                                    
  .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
    content: ">";
    display: inline-block;
    padding: 10px;
    border-right: 1px solid #ddd;
  }
  
  .nav-tabs>li {
    float:left;
    margin-bottom:0; 
  }

</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(ImmuneSpaceR)
library(tidyr)
library(data.table)
library(plotly)
library(Rtsne)
```

```{r params}
  # Non-User Selected Params
  filteredPids <- labkey.url.params$filteredPids

  # Main Params
  aggregateBy <- labkey.url.params$aggregateBy
  assays <- strsplit(labkey.url.params$assays, ",")[[1]]
  timePts <- strsplit(labkey.url.params$timePts, ",")[[1]]
  plotType <- labkey.url.params$plotType
  
  # additional options
  perplexity <- as.integer(labkey.url.params$perplexity)
  numComponents <- as.integer(labkey.url.params$numComponents)
  impute <- labkey.url.params$impute
  responseVar <- labkey.url.params$responseVar
```

```{r pidsFilter}
# use participantId filter to make sure project level filtering on
# dataFinder is transferred to report
pidsFilt <- Rlabkey::makeFilter(c("participantId", "IN", filteredPids))
```


```{r projLvl}
projLvl <- !grepl("SDY\\d{2,4}", labkey.url.path)
```

```{r helpers}

.prettyAssayNames <- function(uglyAssayNames){ 
  prettyAssayName <- sapply(uglyAssayNames, function(x) {
    switch(x,
           "elisa" = "Elisa",
           "elispot" = "Elispot",
           "mbaa" = "MBAA",
           "pcr" = "PCR",
           "fcs_analyzed_result" = "Flow Cytometry",
           "gene_expression_files" = "Gene Expression",
           "hai" = "HAI",
           "neut_ab_titer" = "Neutralizing Antibody Titer"
    )
  }, USE.NAMES = FALSE)
  return(prettyAssayName)
}


getAssayData <- function(assay, con, pidsFilt, filteredPids, timePts) {
  # Get data with default transformation method unless gene expression which
  # needs special treatment to organize in appropriate format
  if(assay != "gene_expression_files"){
    original_view <- assay != "mbaa"
    dat <- con$getDataset(assay, 
                          original_view = original_view, 
                          transformMethod = "auto", 
                          colFilter = pidsFilt)
  }else{
    # Use filteredPids to only download matrices for specified studies and then
    # subset data by filtered gef to ensure only correct pids picked up.
    tmp <- strsplit(filteredPids, ";")
    tmp <- lapply(tmp, strsplit, split = "\\.")[[1]]
    sdys <- paste0("SDY", unique(sapply(tmp, "[", 2)))
    mats <- con$cache$GE_matrices$name[ con$cache$GE_matrices$folder %in% sdys ]
    eset <- con$getGEMatrix(mats)
    dat <- data.frame(t(Biobase::exprs(eset)),stringsAsFactors = FALSE)
    dat$biosample_accession <- rownames(dat)
    
    # Subset by filtered gef and add participant_id and study_time_collected
    gef <- con$getDataset("gene_expression_files", 
                          original_view = TRUE, 
                          colFilter = pidsFilt)
    
    dat <- dat[ dat$biosample_accession %in% gef$biosample_accession, ]
    matchOrder <- match(rownames(dat), gef$biosample_accession)
    dat$study_time_collected <- gef$study_time_collected[ matchOrder ]
    dat$study_time_collected_unit <- gef$study_time_collected_unit[ matchOrder]
    dat$participant_id <- gef$participant_id[ matchOrder ]
    
  }
  
  # Update stc_key to use underscore and replace negative sign for later use in colnames
  dat$stc_key <- paste(dat$study_time_collected, dat$study_time_collected_unit, sep = "_")
  dat <- dat[ dat$stc_key %in% gsub(" ", "_", timePts), ]
  dat$stc_key <- gsub("-", "neg", dat$stc_key)
  
  # Avoid downstream errors by returning NULL if assay does not contain chosen timepoints
  if(nrow(dat) == 0){ return() } 
  
  # Transform assay data to be in following format:
  # One row for biosample with the following columns:
  # * biosample_accession
  # * participant_id
  # * stc_key
  # * one column for each feature
  
  # ---------------- HAI, NAb ----------------- 
  # Grouping by biosample instead of biosample * virus, otherwise same mechanics as other assays
  if( assay %in% c("hai","neut_ab_titer") ){
    dat$value_reported <- as.numeric(dat$value_reported)
    dat <- dat[, lapply(.SD, mean), .(biosample_accession, participant_id, stc_key), .SDcols = c("value_reported")]
    sum_col <- paste0("mean_", assay)
    setnames(dat, "value_reported", sum_col)
    
    
  # ---- ELISA, ELISPOT, MBAA, PCR, FCS  ------ 
  } else if ( assay %in% c("elisa", "elispot", "mbaa", "pcr", "fcs_analyzed_result") ) {
    valCol <- switch( assay,
          "elisa" = "value_preferred",
          "elispot" = "spot_number_reported",
          "mbaa" = "concentration_value",
          "pcr" = "value_reported",
          "fcs_analyzed_result" = "population_cell_number"
        )
    grpByCol <- switch( assay,
          "elisa" = "analyte",
          "elispot" = "analyte",
          "mbaa" = "analyte",
          "pcr" = "gene_symbol",
          "fcs_analyzed_result" = "population_definition_reported"
        )
    dat[[valCol]] <- as.numeric(dat[[valCol]]) # some assays seem to have issues with types
    keepCols <- c("participant_id", "biosample_accession", "stc_key", grpByCol, valCol)
    dat <- dat[ , keepCols, with = FALSE ]
    
    # Aggregate by biosample (should aggregate any technical replicates)
    dat <- dat[, lapply(.SD, mean), by = c("participant_id", "biosample_accession", "stc_key", grpByCol), .SDcols = c(valCol)]
    dat <- spread(dat, key = grpByCol, value = valCol)
    
  # ------------ Gene Expression ------------
    } else if ( assay == "gene_expression_files" ) {
    # Be sure to only subset by GE timepoints not all assay time points!
    geOnlyTp <- unique(dat$stc_key)
    
    # Remove extraneous columns
    setDT(dat)
    dat <- dat[, grep("study_time_collected", colnames(dat), invert = T), with = FALSE]
    
    # Aggregate by biosample
    dat <- dat[, if (nrow(.SD) > 1) { lapply(.SD, mean) } else {.SD}, by = c("participant_id", "biosample_accession", "stc_key"), .SDcols = !c("participant_id", "biosample_accession", "stc_key")]
    }
  return(dat)
}


# getSampleMetadata: returns a data.table with: 
# participant_id, cell_type, and (if applicable) FAS
# Where cell_type is a string with cell type from all assays eg: 
# GE: PBMC\nFlow: Whole Blood\nMBAA: macrophage
getSampleMetadata <- function(aData) {
  # Get participant_ids and biosamples
  sampleInfo <- setDT(Rlabkey::labkey.selectRows(labkey.url.base, 
                                  labkey.url.path,
                                  schemaName = "immport",
                                  queryName = "dimsample",
                                  colFilter =  Rlabkey::makeFilter(c("subjectid", "IN", filteredPids)),
                                  colSelect = c("sampleid", "type"),
                                  colNameOpt = "fieldname"))
  
  participantBiosampleList <- lapply(names(aData), function(assayName){
    participantBiosampleMap <- aData[[assayName]][, .(participant_id, biosample_accession, assay = assayName)]
    participantBiosampleMap <- merge(participantBiosampleMap, sampleInfo[, .(sample_type = type), sampleid],
                                     by.x = "biosample_accession", by.y = "sampleid", 
                                     all.x = TRUE, all.y = FALSE)
  })
  biosampleMetadata <- Reduce(function(x,y){rbind(x,y)}, participantBiosampleList)
  if ("gene_expression_files" %in% names(aData) ){
    # add FAS info
    inputSamplesWithFeatures <- setDT(Rlabkey::labkey.selectRows(labkey.url.base, 
                                  labkey.url.path,
                                  schemaName = "assay.ExpressionMatrix.matrix",
                                  queryName = "inputSamplesWithFeatures",
                                  colNameOpt = "fieldname",
                                  colFilter = pidsFilt,
                                  colSelect = c("Biosample", "featureSet")))
    fas <- setDT(Rlabkey::labkey.selectRows(labkey.url.base, 
                                  labkey.url.path,
                                  schemaName = "microarray",
                                  queryName = "FeatureAnnotationSet",
                                  colNameOpt = "fieldname", 
                                  colSelect = c("RowId", "Name", "Vendor")))
    sample_fas <- merge(inputSamplesWithFeatures[, .(Biosample, featureSet)], fas, 
                        by.x = "featureSet", by.y = "RowId",
                        all.x = TRUE, all.y = FALSE)
    
    biosampleMetadata <- merge(biosampleMetadata, sample_fas,
                                   by.x = "biosample_accession", by.y = "Biosample",
                                   all.x = TRUE, all.y = FALSE)
    setnames(biosampleMetadata, c("Name", "Vendor"), c("fasName", "fasVendor"))
  }
  
  # aggregate by participant_id and tp
  # helper for creating sample type text (eg "GE: PBMC\nFlow: Whole Blood\nMBAA: macrophage")
  createSampleTypeText <- function(assays, sampleTypes) {
    combos <- unique(data.table(assay = assays, sampleType = sampleTypes))
    comboText <- lapply(seq_len(nrow(combos)), function(i) {paste0(.prettyAssayNames(combos[i]$assay), ": ", combos[i]$sampleType)})
    return(paste0(comboText, collapse = "\n"))
  }
  
  if ("gene_expression_files" %in% names(aData) ) {
      participantMetadata <- biosampleMetadata[, .(sample_type = createSampleTypeText(assay, sample_type), 
                                               fasName = paste0(unique(na.omit(fasName)), collapse = ", "),
                                               fasVendor = paste0(unique(na.omit(fasVendor)), collapse = ", ")), participant_id]
  } else {
    participantMetadata <- biosampleMetadata[, .(sample_type = createSampleTypeText(assay, sample_type)), participant_id]
  }

  
  return(participantMetadata)
}


# aggregateAssayData: given a data.table in the format returned by getAssayData, 
# this function will: 
# 1. aggregate any technical replicates (repeated values for the same feature for the same participant at a given timepoint)
# 2. transform the data based on aggregateBy: 
#    aggregateBy = "subject" -> One row per subject, one column for each feature-timepoint combo 
#                               (excludes participants who don't have data at every timepoint)
#    aggregateBy = "subject-tp" -> One row per subject-timepoint combo, one column for each feature
aggregateAssayData <- function(dat, aggregateBy) {
  
  tps <- unique(dat$stc_key)
  # Aggregate by participant & timepoint
  datByTp <- dat[, if (nrow(.SD) > 1) { lapply(.SD, function(x){mean(x, na.rm = TRUE)}) } else {.SD}, by = c("participant_id", "stc_key"), .SDcols = !c("participant_id", "biosample_accession", "stc_key")]
      
    # } else if (aggregateBy == "subject-tp"){
    #   # Aggregate by participant & timepoint
    #   datByTp <- dat[, if (nrow(.SD) > 1) { lapply(.SD, mean) } else {.SD}, by = c("participant_id", "stc_key"), .SDcols = !c("participant_id", "biosample_accession", "stc_key")]
    # }
  
  # Get into correct format depending on aggregateBy
  if ( aggregateBy == "subject" ) {
    dats <- lapply(tps, function(tp){
        mat <- datByTp[ datByTp$stc_key == tp, ]
        mat <- mat[, -"stc_key", with = FALSE]
        nms <- colnames(mat)
        nms <- ifelse(!grepl("participant_id|stc_key", nms), paste0(nms, "_", tp), nms)
        colnames(mat) <- nms
        return(mat)
      })
      dat <- Reduce(function(x,y){ merge(x, y, by.x = c("participant_id"), by.y = c("participant_id")) }, dats)
  } else if ( aggregateBy == "subject-tp" ) { 
    dat <- datByTp
    dat$sub_tp <- paste(dat$participant_id, dat$stc_key, sep = "_")
    dat <- dat[, -"stc_key"]
    dat <- dat[, -grep("biosample_accession|participant_id", colnames(dat)), with = FALSE]
  }
  
  return(dat)
}

# return a matrix with rownames = participant_id and colnames = feature
datToMat <- function(dat) {
  featuresDT <- dat[, -grep("participant_id|sub_tp", colnames(dat)), with = FALSE]
  featuresMat <- apply(featuresDT, 2, as.numeric)
  rownames(featuresMat) <- unlist(dat[, grep("participant_id|sub_tp", colnames(dat)), with = FALSE])
  return(featuresMat)
}
```


```{r prep-assay-data, results = 'hide'}
# Pulling labkey.url.base and labkey.url.path from injected code and using this
# to set up connection
con <- CreateConnection()

# get assay data
# NOTES:
# 1. When aggregateBy == "subject", GE data is subset to subjects with all timepoints
# Otherwise too much imputation is done and would affect subjects score.
# 2. If impute == "none", then assay data matrix is cut down to only subjects with
# every assay * timepoint combination. This could be highly limiting in project level work.
# 3. When there are multiple records for a subject at a timepoint, they are aggregated by mean. 
# 4. When impute != "none", variables with > 80% of values missing (for included subjects) will be dropped
# to limit imputation
aData <- lapply(assays,
                getAssayData,
                con = con,
                pidsFilt = pidsFilt,
                filteredPids = filteredPids,
                timePts = timePts)
# aData <- get(load("~/aData_orig.RData"))
names(aData) <- assays

# Check aData to be sure non-null
nulls <- sapply(aData, is.null)
aData <- aData[ !nulls ]

# When aggregateBy == "subject", GE data is subset to subjects with all timepoints
# Otherwise too much imputation is done and would affect subjects score.
if ( aggregateBy == "subject" & "gene_expression_files" %in% assays ) { 
  dat <- aData$gene_expression_files
  tps <- unique(dat$stc_key)
  
  # Figure out subs with all tp
  subTps <- vapply(unique(dat$participant_id), 
                   function(x){list(unique(dat$stc_key[ dat$participant_id == x]))},
                   FUN.VALUE = list(c("6_hours", "12_hours")))
  goodSubs <- vapply(names(subTps), 
                     function(x){all(tps %in% subTps[[x]])}, 
                     FUN.VALUE = TRUE)
  goodSubs <- names(goodSubs)[goodSubs]
  
  aData$gene_expression_files <- dat[participant_id %in% goodSubs]
}

# Get sample-level additional data
if (projLvl) {
  extraMetadata <- getSampleMetadata(aData)
}

# Aggregate
aData <- lapply(aData,
                aggregateAssayData, 
                aggregateBy = aggregateBy)

# Change datasets to matrices (rownames = participant_id/sub_tp, colnames = feature)
aData <- lapply(aData,
                datToMat)

# record of all subjects (before dropping for missing data)
allSubs <- unique(unlist(lapply(aData, rownames)))
```


```{r missing_data, results="hide"}

# Deal with missing data (impute and trim) ---------------------
if ( impute == "none" ) {
  # when impute == "none", remove subjects with missing features
  aData <- lapply(aData, function(df){ 
    df <- df[ complete.cases(df), ]
  })
  
  # Are there any assays which do not have any subjects without missing features?
  prbAssays <- sapply(aData, function(x){ return(dim(x)[[1]] == 0 )} )
  prbAssays <- assays[ prbAssays ]
  if (length(prbAssays) > 0 ) {
    prbAssays <- sapply(prbAssays, function(x){ 
      x <- switch(x,
                  "elisa" = "Elisa",
                  "elispot" = "Elispot",
                  "mbaa" = "MBAA",
                  "pcr" = "PCR",
                  "fcs_analyzed_result" = "Flow Cytometry",
                  "gene_expression_files" = "Gene Expression",
                  "hai" = "HAI",
                  "neut_ab_titer" = "Neutralizing Antibody Titer"
      )
    })
    stop(paste0("R Report Error: Some assays do not have any subjects with complete cases. Select an imputation method or remove problematic assays (", paste(prbAssays, collapse = ", "), ")."))
  }
}

if (impute != "none") {
  
  missingDataList <- lapply(aData, function(mat){
    missingData <- is.na(mat)
  })
  
  # Drop any features with > 80% missing values 
  aData <- mapply(
    function(mat, missingData) {
      keepFeatures <- apply(missingData, 2, function(x){sum(x)/length(x) <= 0.8})
      mat <- mat[, keepFeatures]
      list(mat)
    },
    aData, 
    missingDataList)
  
  # Drop any subjects with > 80% missing values
  aData <- mapply(
    function(mat, missingData) {
      keepSubjects <- apply(missingData[, colnames(mat)], 1, function(x){sum(x)/length(x) <= 0.8})
      mat <- mat[keepSubjects, ]
      list(mat)
    },
    aData,
    missingDataList
  )
  
}


# Impute missing values within each assay on per sample or sample_tp (column) basis if selected by user
if(impute == "mean" | impute == "median"){
  fn <- get(impute)
  aData <- lapply(aData, function(mat){
    mat <- apply(mat, 2, function(x){
      x[ is.na(x) ] <- fn(x, na.rm = TRUE)
      return(x)
    })
  })
}else if(impute == "knn"){
  library(impute)
  # For impute.knn, data should be "An expression matrix
  # with genes in rows, samples in columns"

  aData <- lapply(aData, function(mat){ 
    
    # Impute
    res <- impute::impute.knn(t(mat))
    
    # Transform back
    mat <- t(res$data)

    return(mat)
  })
  
}
```

```{r combine_and_prep, results="hide"}

# Find subs with all datasets (drop subjects without all datasets AFTER imputation)
subs <- lapply(aData, function(x){
  rownames(x)
})
numSubs <- table(unlist(subs))
subs <- names(numSubs)[ numSubs == length(aData) ]

if(length(subs) < 2){
  stop("R Report Error: Fewer than two subjects available for analysis across all assays. Select imputation method other than 'None' and retry.")
}

# combine, including only subs with all datasets
allMat <- Reduce(function(x,y){cbind(x[subs,],y[subs,])}, aData)
allMat <- allMat[subs, ]

# normalize after ensuring numeric
allMat <- scale(allMat)

# remove any features that have no variance
noVariance <- apply(allMat, 2, function(x){ return(length(unique(x)) == 1)})
allMat <- allMat[ , !noVariance, drop = FALSE ]

if( is.null(dim(allMat)) || dim(allMat)[2] < 2){
  stop("R Report Error: Too few variables selected. Please select more assays or timepoints and re-run.")
}
```


```{r prep-demog-data}
# Get demographic data and add cohort name
demog <- con$getDataset("demographics", colFilter = pidsFilt)

# Add immune exposure
immex <- setDT(Rlabkey::labkey.selectRows(
  labkey.url.base,
  labkey.url.path,
  "immport",
  "immune_exposure",
  colNameOpt = "fieldname"
))

demog$subject_accession <- sub("\\.\\d", "", demog$participant_id)
demog <- merge(demog, immex[, .(subject_accession, disease_reported, disease_stage_reported, exposure_material_reported, exposure_process_reported)],
               by = "subject_accession",
               all.x = TRUE,
               all.y = FALSE)

if (impute != "none") {
  # Add number of of imputed features to demog
  # 
  allImputeMat <- Reduce(function(x,y){cbind(x[subs,],y[subs,])}, missingDataList)
  allImputeMat <- allImputeMat[subs,] # subset to only good subs if length(missingDataList) == 1
  droppedFeatureCount <- dim(allImputeMat)[2] - dim(allMat)[2] - sum(noVariance)
  allImputeMat <- allImputeMat[, colnames(allMat)]
  imputed_values <- apply(allImputeMat, 1, sum)
  
  # demog[, imputed_values := imputed_values[participant_id]]
}

if (projLvl) {
  # Add cell type
  demog <- merge(demog, extraMetadata, 
                 by = "participant_id",
                 all.x = TRUE,
                 all.y = FALSE)
}

# Replace NA values with "Not Specified"
demog[is.na(demog)] <- "Not Specified"
# Make sure numeric columns are numeric
demog[, age_reported := as.numeric(age_reported)]
```




## Parameters
- **Timepoints**: `r timePts`
- **Assays**: `r assays`
- **Time As**: `r aggregateBy`
- **Plot Type**: `r plotType`
- **Number of Components Analyzed**: `r numComponents`
- **Imputation Method**: `r impute`
- **Immune Response Label**: `r responseVar`

## General Information
Note: Only subjects with assay data at all timepoints are included in the final
dimension reduction analysis. By default, there is no imputation. If you do select
to impute data, it is done within the individual assay data prior to combining multiple
assays.  For gene-expression data, imputation only occurs if subjects have at least
partial data for the timepoint. For non-gene-expression data, imputation does not require
partial data for the timepoint (e.g. some hai strains but not others).

- **Number of Observations (Subjects)**: `r dim(allMat)[1]`
- **Number of Observations Removed due to missing data**: `r length(numSubs[ numSubs < length(aData)])`
- **Number of Observations Removed due to missing features**: `r length(allSubs) - length(numSubs[ numSubs < length(aData)]) - length(subs)`
- **Number of Features Used (Assay Data)**: `r dim(allMat)[2]`
- **Number of Features Removed Due to Lack of Variance**: `r sum(noVariance)`


`r if ( impute != "none" ) {paste0("- **Number of Observations with imputed values**: ", sum(imputed_values > 0))}`
`r if ( impute != "none" ) {paste0("- **Number of Features with imputed values**: ", sum(apply(allImputeMat, 2, sum) > 0))}`
`r if ( impute != "none" ) {paste0("- **Total Number of Imputed Values**: ", sum(allImputeMat))}`
`r if ( impute != "none" ) {paste0("- **Number of Features Removed Due to Lack of Data**: ", droppedFeatureCount)}`


```{r plot helpers}
# helper for iterating through multiple components
genPlot <- function(i, j, resObj, type, prettyLbl, colorCol){
  if(type == "tSNE"){
    df <- data.frame(x = resObj$Y[,i],
                     y = resObj$Y[,j],
                     stringsAsFactors = FALSE)
    x_annotation <- ""
    y_annotation <- ""
  }else{
    df <- data.frame(x = resObj$x[, paste0("PC",i)],
                     y = resObj$x[, paste0("PC",j)],
                     stringsAsFactors = FALSE)
    x_annotation <- paste0(" (", round(summary(resObj)$importance["Proportion of Variance", i]*100, 2), "%)")
    y_annotation <- paste0(" (", round(summary(resObj)$importance["Proportion of Variance", j]*100, 2), "%)")
  }

  p <- plot_ly(data = df,
               x = ~x,
               y = ~y,
               type = "scatter",
               mode = "markers",
               marker = list(size = 14),
               color = colorCol,
               hoverinfo = 'text',
               text = paste(prettyLbl, ": ", colorCol, "<br>ID: ", subs)) %>%
    layout(xaxis = list(title = paste0(type, i, x_annotation)),
           yaxis = list(title = paste0(type, j, y_annotation)),
           annotations = list(yref = 'paper',
                              xref = 'paper',
                              y = 1.02,
                              x = 1.175,
                              text = prettyLbl,
                              showarrow = FALSE),
           autosize = T,
           width = 700,
           showlegend=TRUE)
}

makePlot <- function(label, aggregateBy, demog, numComponents, plotType, allMat){
  prettyLbl <- tools::toTitleCase(gsub("_", " ", label))

  if(label == "time"){
    colorCol <- gsub("^SUB\\d{5,6}\\.\\d{2,4}_", "", subs)
  }else if(label == "study"){
    colorCol <- gsub("^SUB\\d{5,6}\\.", "", subs)
    colorCol <- paste0("SDY", gsub("_\\d+$", "", colorCol))
  }else if(label %in% c("hai", "neut_ab_titer")){
    re <- re[participant_id %in% subs ]
    # create response value from fold-change compared to baseline for each virus
    re <- re[, list(arm_accession, study_time_collected, study_time_collected_unit,
                    response = value_reported/mean(value_reported[study_time_collected<=0])),
             by = "virus,participant_id"]
    # determine mean response for each study day across virus
    re <- re[, mr := mean(response, na.rm=T), by = "study_time_collected"]
    # determine maximum mean response for each cohort for each study day
    re <- re[, ma := max(mr, na.rm=T), by = "arm_accession"]
    # Determine the peak study day for each cohort
    peak <- unique(re[mr == ma, list(study_time_collected, arm_accession)])
    # Use merge to filter to study days for peak response by cohort
    re <- merge(re, peak, by=c("study_time_collected", "arm_accession"))
    # provide single response for each participant by taking the log of max
    re <- re[, list(response = log2(max(response))), by = "participant_id"]
    # Dichotomize the participants into high and low responders arbitrarily at log2(4)
    # based on default values in IRP
    re <- re[, response := ifelse(response >= log2(4), "high responder",  "low responder")]
    colorCol <- re$response[order(match(subs, re$participant_id))]
  }else if (label == "imputed_values") {
    colorCol <- imputed_values
  } else{
    if(aggregateBy == "subject-tp"){ subs <- gsub("_.+", "", subs) }
    colorCol <- demog[[label]][ match(subs, demog$participant_id)]
  }
  # create and sort possible component combinations
  poss <- expand.grid(j = 1:numComponents, i = 1:numComponents)
  poss <- poss[ poss$j != poss$i, ]
  poss$test <- sapply(1:nrow(poss), function(x){
    paste(sort(c(poss[x,1], poss[x,2])), collapse = ":")
  })
  poss <- poss[ !duplicated(poss$test), ]

  # Run analysis and get pieces together for plotting
  if(plotType == "tSNE"){
    # perplexity * 2 < nrow(x) - 1
    if (perplexity > (nrow(allMat) - 1)/3) {
      minPerplexity <- floor((nrow(allMat) - 1)/3)
      stop(paste0("R Report Error: Perplexity is too large for the number of samples. Select perplexity <= ", minPerplexity))
    }
    set.seed(8)
    # Avoid duplicate rows by adding random noise
    if( any(duplicated(allMat)) ){
      allMat[,1] <- jitter(allMat[,1], factor = 1, amount = NULL)
    }
    tRes <- Rtsne::Rtsne(allMat, dims = numComponents, perplexity = perplexity)
    moreArgs <- list(resObj = tRes, type = "tSNE", prettyLbl = prettyLbl, colorCol = colorCol)
  }else{
    pca <- prcomp(allMat)
    moreArgs <- list(resObj = pca, type = "PCA", prettyLbl = prettyLbl, colorCol = colorCol)
  }

  plots <- mapply(genPlot,
                  i = poss$i,
                  j = poss$j,
                  MoreArgs = moreArgs,
                  SIMPLIFY = FALSE
  )
}
```

## Plots {.tabset .tabset-fade .tabset-dropdown} 

```{r getPlots}
re <- tryCatch(
  con$getdataset(responseVar, original_view = TRUE),
  warning = function(w) return(w),
  error = function(e) return(e)
)
IRcondition <- is.null(re$message)

plotLabels <- list("age_reported" = TRUE,
                "gender" = TRUE,
                "ethnicity" = TRUE,
                "race" = TRUE,
                "cohort" = TRUE,
                "study" = projLvl,
                "time" = aggregateBy == "subject-tp",
                "immune_response" = IRcondition,
                "imputed_values" = impute != "none",
                "sample_type" = projLvl,
                "fas_name" = projLvl & "gene_expression_files" %in% assays,
                "fas_vendor"= projLvl & "gene_expression_files" %in% assays,
                "immune_exposure" = projLvl,
                "immune_exposure_type" = projLvl)
```



`r if (plotLabels$age_reported) {"### Age"}`
```{r  Age, fig.align="left", eval = plotLabels$age_reported}
  plots <- makePlot(label = "age_reported",
                    aggregateBy = aggregateBy,
                    demog = demog,
                    numComponents = numComponents,
                    plotType = plotType,
                    allMat = allMat
  )
  htmltools::tagList(plots)
```

`r if (plotLabels$gender) {"### Gender"}`
```{r  gender, fig.align="left", eval = plotLabels$gender}
plots <- makePlot(label = "gender",
                  aggregateBy = aggregateBy,
                  demog = demog,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```

`r if (plotLabels$ethnicity) {"### Ethnicity"}`
```{r  ethnicity, fig.align="left", eval = plotLabels$ethnicity}
plots <- makePlot(label = "ethnicity",
                  aggregateBy = aggregateBy,
                  demog = demog,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```

`r if (plotLabels$race) {"### Race"}`
```{r  race, fig.align="left", eval = plotLabels$race}
plots <- makePlot(label = "race",
                  aggregateBy = aggregateBy,
                  demog = demog,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```


`r if (plotLabels$study) {"### Study"}`
```{r  study, fig.align="left", eval = plotLabels$study}
plots <- makePlot(label = "study",
                  aggregateBy = aggregateBy,
                  demog = demog,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```

`r if (plotLabels$cohort) {"### Cohort"}`
```{r  cohort, fig.align="left", eval = plotLabels$cohort}
plots <- makePlot(label = "cohort",
                  aggregateBy = aggregateBy,
                  demog = demog,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```

`r if (plotLabels$time) {"### Timepoint"}`
```{r  timePt, fig.align="left", eval = plotLabels$time}
plots <- makePlot(label = "time",
                  aggregateBy = aggregateBy,
                  demog = demog,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```

`r if (plotLabels$immune_response) {"### Immune Response"}`
`r if (plotLabels$immune_response) {"Note: Not all subjects may have immune repsonse data"}`

```{r IR, fig.align="left", eval = plotLabels$immune_response}
re <- tryCatch(
  con$getDataset(responseVar, original_view = T),
  warning = function(w) return(w),
  error = function(e) return(e)
)
if(is.null(re$message)){
  plots <- makePlot(label = responseVar,
                    aggregateBy = aggregateBy,
                    demog = demog,
                    numComponents = numComponents,
                    plotType = plotType,
                    allMat = allMat
  )
  htmltools::tagList(plots)
}else{
  cat(paste0("Response variable ", responseVar, " returns empty data frame from study.  Data is not available for given participants."))
}
```

`r if (plotLabels$imputed_values) {"### Imputed Values"}`
```{r Imputed, fig.align="left", eval = plotLabels$imputed_values}
plots <- makePlot(label = "imputed_values",
                  aggregateBy = aggregateBy,
                  demog = demog,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```

`r if (plotLabels$sample_type) {"### Sample Type"}`
```{r Sample, fig.align="left", eval = plotLabels$sample_type}
plots <- makePlot(label = "sample_type",
                  aggregateBy = aggregateBy,
                  demog = demog,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```


`r if (plotLabels$fas_name) {"### Feature Annotation Set"}`
```{r FAS, fig.align="left", eval = plotLabels$fas_name}
plots <- makePlot(label = "fasName",
                  aggregateBy = aggregateBy,
                  demog = demog,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```

`r if (plotLabels$fas_vendor) {"### FAS Vendor"}`
```{r fasVendor, fig.align="left", eval = plotLabels$fas_vendor}
plots <- makePlot(label = "fasVendor",
                  aggregateBy = aggregateBy,
                  demog = demog,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```

`r if (plotLabels$immune_exposure) {"### Immune Exposure Material"}`
```{r immune_exposure, fig.align="left", eval = plotLabels$immune_exposure}
plots <- makePlot(label = "exposure_material_reported",
                  aggregateBy = aggregateBy,
                  demog = demog,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```

`r if (plotLabels$immune_exposure_type) {"### Immune Exposure Type"}`
```{r immune_exposure_type, fig.align="left", eval = plotLabels$immune_exposure_type}
plots <- makePlot(label = "exposure_process_reported",
                  aggregateBy = aggregateBy,
                  demog = demog,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```

<script>
window.HTMLWidgets.staticRender();
</script>

