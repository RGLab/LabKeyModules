---
output: html_document
---
<style>
  .tabset-dropdown > .nav-tabs > li.active:before {
    content: ">";
    display: inline-block;
    padding: 10px;
    border-right: 1px solid #ddd;
  }
                      
  .tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
    content: ">";
    border: none;
  }
                                    
  .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
    content: ">";
    display: inline-block;
    padding: 10px;
    border-right: 1px solid #ddd;
  }
  
  .nav-tabs>li {
    float:left;
    margin-bottom:0; 
  }

</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(ImmuneSpaceR)
library(tidyr)
library(data.table)
library(plotly)
library(Rtsne)
```

```{r testing, eval = FALSE}
# labkey.url <- function (controller, action, list){paste(labkey.url.base,controller,labkey.url.path,action,".view?",paste(names(list),list,sep="=",collapse="&"),sep="")}
# labkey.resolveLSID <- function(lsid){paste(labkey.url.base,"experiment/resolveLSID.view?lsid=",lsid,sep="");}
labkey.user.email="hmiller@fredhutch.org"
labkey.url.path="/Studies/"
labkey.url.base="http://140.107.149.233:8080/"
labkey.url.params <- list(
  "timePts"="7 Days,1 Days",
  "assays"="gene_expression_files,fcs_analysed_results",
  "responseVar"="hai",
  "plotType"="PCA",
  "impute"="none",
  "perplexity"="5",
  "aggregateBy"="subject",
  "filteredPids"="SUB112829.269;SUB112831.269;SUB112832.269;SUB112834.269;SUB112838.269;SUB112842.269;SUB112843.269;SUB112847.269;SUB112850.269;SUB112854.269;SUB112857.269;SUB112858.269;SUB112859.269;SUB112861.269;SUB112866.269;SUB112867.269;SUB112868.269;SUB112869.269;SUB112870.269;SUB112873.269;SUB112877.269;SUB112884.269;SUB119252.180;SUB119254.180;SUB119255.180;SUB119267.180;SUB119268.180;SUB119269.180;SUB119270.180;SUB119272.180;SUB119273.180;SUB119275.180;SUB119276.180;SUB119278.180;SUB119281.180;SUB119284.180;SUB119287.180;SUB119288.180;SUB119289.180;SUB119291.180;SUB119293.180;SUB119294.180;SUB119296.180;SUB153740.597;SUB153741.597;SUB153743.597;SUB153744.597;SUB153746.597;SUB153748.597;SUB153750.597;SUB71252.28;SUB71272.28;SUB71275.28;SUB71308.28;SUB71315.28;SUB71322.28;SUB71326.28;SUB71341.28;SUB71347.28;SUB71389.28;SUB71391.28;SUB71399.28;SUB71401.28;SUB71419.28;SUB71446.28;SUB71461.28;SUB71474.28;SUB71482.28;SUB71497.28;SUB71538.28;SUB71540.28;SUB71574.28;SUB71577.28;SUB71594.28;SUB71613.28;SUB71619.28;SUB71621.28;SUB71628.28;SUB71635.28;SUB71645.28;SUB71647.28;SUB71648.28;SUB71652.28;SUB71654.28;SUB71656.28;SUB71658.28;SUB71659.28;SUB71665.28;SUB71691.28;SUB71692.28;SUB71704.28;SUB71705.28;SUB71724.28;SUB71728.28;SUB71734.28;SUB71763.28;SUB71764.28;SUB71773.28;SUB71782.28;SUB71791.28;SUB71807.28;SUB71814.28;SUB71832.28;SUB71842.28;SUB71850.28;SUB71857.28;SUB71873.28;SUB71884.28;SUB71885.28;SUB71891.28;SUB71901.28;SUB71902.28;SUB71952.28;SUB71959.28;SUB71991.28;SUB71994.28;SUB72000.28;SUB72008.28;SUB72010.28;SUB72018.28;SUB72024.28;SUB72026.28;SUB72035.28;SUB72047.28;SUB72052.28;SUB72078.28;SUB72086.28;SUB72103.28;SUB72111.28;SUB72115.28;SUB72127.28;SUB72132.28;SUB72136.28;SUB72141.28;SUB72151.28;SUB72186.28;SUB72218.28;SUB72234.28;SUB72257.28;SUB72260.28;SUB72261.28;SUB72264.28;SUB72267.28;SUB72274.28;SUB72283.28;SUB72287.28;SUB72307.28;SUB72312.28",
  "numComponents"="2")
# labkey.file.root <- "/share/files/Studies/@files"
# labkey.pipeline.root <- "/share/files/Studies/@files"
# labkey.sessionCookieName = "JSESSIONID"
# labkey.sessionCookieContents = "59D7397057B93889ABF693C440BC1EB3"
```

```{r params}
  # Non-User Selected Params
  filteredPids <- labkey.url.params$filteredPids

  # Main Params
  aggregateBy <- labkey.url.params$aggregateBy
  assays <- strsplit(labkey.url.params$assays, ",")[[1]]
  timePts <- strsplit(labkey.url.params$timePts, ",")[[1]]
  plotType <- labkey.url.params$plotType
  
  # additional options
  perplexity <- as.integer(labkey.url.params$perplexity)
  numComponents <- as.integer(labkey.url.params$numComponents)
  impute <- labkey.url.params$impute
  responseVar <- labkey.url.params$responseVar
```

```{r pidsFilter}
# use participantId filter to make sure project level filtering on
# dataFinder is transferred to report
pidsFilt <- Rlabkey::makeFilter(c("participantId", "IN", filteredPids))
```


```{r projLvl}
projLvl <- !grepl("SDY\\d{2,4}", con$config$labkey.url.path)
```

```{r getAssayData}
getAssayData <- function(assay, con, pidsFilt, filteredPids, timePts, aggregateBy) {
  # Get data with default transformation method unless gene expression which
  # needs special treatment to organize in appropriate format
  if(assay != "gene_expression_files"){
    original_view <- assay != "mbaa"
    dat <- con$getDataset(assay, 
                          original_view = original_view, 
                          transformMethod = "auto", 
                          colFilter = pidsFilt)
  }else{
    # Use filteredPids to only download matrices for specified studies and then
    # subset data by filtered gef to ensure only correct pids picked up.
    tmp <- strsplit(filteredPids, ";")
    tmp <- lapply(tmp, strsplit, split = "\\.")[[1]]
    sdys <- paste0("SDY", unique(sapply(tmp, "[", 2)))
    mats <- con$cache$GE_matrices$name[ con$cache$GE_matrices$folder %in% sdys ]
    eset <- con$getGEMatrix(mats)
    dat <- data.frame(t(Biobase::exprs(eset)),stringsAsFactors = FALSE)
    dat$biosample_accession <- rownames(dat)
    
    # Subset by filtered gef and add participant_id and study_time_collected
    gef <- con$getDataset("gene_expression_files", 
                          original_view = TRUE, 
                          colFilter = pidsFilt)
    
    dat <- dat[ dat$biosample_accession %in% gef$biosample_accession, ]
    matchOrder <- match(rownames(dat), gef$biosample_accession)
    dat$study_time_collected <- gef$study_time_collected[ matchOrder ]
    dat$study_time_collected_unit <- gef$study_time_collected_unit[ matchOrder]
    dat$participant_id <- gef$participant_id[ matchOrder ]
    
  }
  
  # Update stc_key to use underscore and replace negative sign for later use in colnames
  dat$stc_key <- paste(dat$study_time_collected, dat$study_time_collected_unit, sep = "_")
  dat <- dat[ dat$stc_key %in% gsub(" ", "_", timePts), ]
  dat$stc_key <- gsub("-", "neg", dat$stc_key)
  
  # Avoid downstream errors by returning NULL if assay does not contain chosen timepoints
  if(nrow(dat) == 0){ return() } 
  
  # Transform assay data to be in following format:
  # One row for biosample with the following columns:
  # * biosample_accession
  # * participant_id
  # * stc_key
  # * one column for each feature
  
  # ---------------- HAI, NAb ----------------- 
  # Grouping by biosample instead of biosample * virus, otherwise same mechanics as other assays
  if( assay %in% c("hai","neut_ab_titer") ){
    dat$value_reported <- as.numeric(dat$value_reported)
    dat <- dat[, lapply(.SD, mean), .(biosample_accession, participant_id, stc_key), .SDcols = c("value_reported")]
    sum_col <- paste0("mean_", assay)
    setnames(dat, "value_reported", sum_col)
    
    
  # ---- ELISA, ELISPOT, MBAA, PCR, FCS  ------ 
  } else if ( assay %in% c("elisa", "elispot", "mbaa", "pcr", "fcs_analyzed_result") ) {
    valCol <- switch( assay,
          "elisa" = "value_preferred",
          "elispot" = "spot_number_reported",
          "mbaa" = "concentration_value",
          "pcr" = "value_reported",
          "fcs_analyzed_result" = "population_cell_number"
        )
    grpByCol <- switch( assay,
          "elisa" = "analyte",
          "elispot" = "analyte",
          "mbaa" = "analyte",
          "pcr" = "gene_symbol",
          "fcs_analyzed_result" = "population_definition_reported"
        )
    dat[[valCol]] <- as.numeric(dat[[valCol]]) # some assays seem to have issues with types
    keepCols <- c("participant_id", "biosample_accession", "stc_key", grpByCol, valCol)
    dat <- dat[ , keepCols, with = FALSE ]
    
    # Aggregate by biosample (should aggregate any technical replicates)
    dat <- dat[, lapply(.SD, mean), by = c("participant_id", "biosample_accession", "stc_key", grpByCol), .SDcols = c(valCol)]
    dat <- spread(dat, key = grpByCol, value = valCol)
    
  # ------------ Gene Expression ------------
    } else if ( assay == "gene_expression_files" ) {
    # Be sure to only subset by GE timepoints not all assay time points!
    geOnlyTp <- unique(dat$stc_key)
    
    # Remove extraneous columns
    setDT(dat)
    dat <- dat[, grep("study_time_collected", colnames(dat), invert = T), with = FALSE]
    
    # Aggregate by biosample
    dat <- dat[, if (nrow(.SD) > 1) { lapply(.SD, mean) } else {.SD}, by = c("participant_id", "biosample_accession", "stc_key"), .SDcols = !c("participant_id", "biosample_accession", "stc_key")]
    }
  return(dat)
}


# getSampleMetadata: returns a data.table with: 
# participant_id, cell_type, and (if applicable) FAS
# Where cell_type is a string with cell type from all assays eg: 
# GE: PBMC\nFlow: Whole Blood\nMBAA: macrophage
getSampleMetadata <- function(aData) {
  # Get participant_ids and biosamples
  sampleInfo <- setDT(Rlabkey::labkey.selectRows(labkey.url.base, 
                                  labkey.url.path,
                                  schemaName = "immport",
                                  queryName = "dimsample",
                                  colFilter =  Rlabkey::makeFilter(c("subjectid", "IN", filteredPids)),
                                  colSelect = c("sampleid", "type"),
                                  colNameOpt = "fieldname"))
  
  participantBiosampleList <- lapply(names(aData), function(assayName){
    participantBiosampleMap <- aData[[assayName]][, .(participant_id, biosample_accession, assay = assayName)]
    participantBiosampleMap <- merge(participantBiosampleMap, sampleInfo[, .(sample_type = type), sampleid],
                                     by.x = "biosample_accession", by.y = "sampleid", 
                                     all.x = TRUE, all.y = FALSE)
  })
  biosampleMetadata <- Reduce(function(x,y){rbind(x,y)}, participantBiosampleList)
  if ("gene_expression_files" %in% names(aData) ){
    # add FAS info
    inputSamplesWithFeatures <- setDT(Rlabkey::labkey.selectRows(labkey.url.base, 
                                  labkey.url.path,
                                  schemaName = "assay.ExpressionMatrix.matrix",
                                  queryName = "inputSamplesWithFeatures",
                                  colNameOpt = "fieldname",
                                  colFilter = pidsFilt,
                                  colSelect = c("Biosample", "featureSet")))
    fas <- setDT(Rlabkey::labkey.selectRows(labkey.url.base, 
                                  labkey.url.path,
                                  schemaName = "microarray",
                                  queryName = "FeatureAnnotationSet",
                                  colNameOpt = "fieldname", 
                                  colSelect = c("RowId", "Name", "Vendor")))
    sample_fas <- merge(inputSamplesWithFeatures[, .(Biosample, featureSet)], fas, 
                        by.x = "featureSet", by.y = "RowId",
                        all.x = TRUE, all.y = FALSE)
    
    biosampleMetadata <- merge(biosampleMetadata, sample_fas,
                                   by.x = "biosample_accession", by.y = "Biosample",
                                   all.x = TRUE, all.y = FALSE)
    setnames(biosampleMetadata, c("Name", "Vendor"), c("fasName", "fasVendor"))
  }
  
  # aggregate by participant_id and tp
  participantMetadata <- biosampleMetadata[, .(sample_type = "", 
                                               fasName = "",
                                               fasVendor = ""), participant_id]
  
  return(participantMetadata)
}

aggregateAssayData <- function(dat, aggregateBy) {
  
    if (aggregateBy == "subject") {
      tps <- unique(dat$stc_key)
      
      # Exclude subjects that do not have data at all timepoints
      # Figure out subs with all tp
      subTps <- vapply(unique(dat$participant_id), 
                       function(x){list(unique(dat$stc_key[ dat$participant_id == x]))},
                       FUN.VALUE = list(c("6_hours", "12_hours")))
      goodSubs <- vapply(names(subTps), 
                         function(x){all(tps %in% subTps[[x]])}, 
                         FUN.VALUE = TRUE)
      goodSubs <- names(goodSubs)[goodSubs]
      
      dat <- dat[participant_id %in% goodSubs]
    }
  
  # Aggregate by participant & timepoint
  datByTp <- dat[, if (nrow(.SD) > 1) { lapply(.SD, mean) } else {.SD}, by = c("participant_id", "stc_key"), .SDcols = !c("participant_id", "biosample_accession", "stc_key")]
      
    # } else if (aggregateBy == "subject-tp"){
    #   # Aggregate by participant & timepoint
    #   datByTp <- dat[, if (nrow(.SD) > 1) { lapply(.SD, mean) } else {.SD}, by = c("participant_id", "stc_key"), .SDcols = !c("participant_id", "biosample_accession", "stc_key")]
    # }
  
  # Get into correct format depending on aggregateBy
  if ( aggregateBy == "subject" ) {
    dats <- lapply(tps, function(tp){
        mat <- datByTp[ datByTp$stc_key == tp, ]
        mat <- mat[, -"stc_key", with = FALSE]
        nms <- colnames(mat)
        nms <- ifelse(!grepl("participant_id|stc_key", nms), paste0(nms, "_", tp), nms)
        colnames(mat) <- nms
        return(mat)
      })
      dat <- Reduce(function(x,y){ merge(x, y, by.x = c("participant_id"), by.y = c("participant_id")) }, dats)
  } else if ( aggregateBy == "subject-tp" ) { 
    dat$sub_tp <- paste(dat$participant_id, dat$stc_key, sep = "_")
    dat <- dat[, -"stc_key"]
  }
  
  return(dat)
}
```


```{r helper-fn, eval = FALSE}
getAssayData <- function(assay, con, pidsFilt, filteredPids, timePts, aggregateBy){

  # Get data with default transformation method unless gene expression which
  # needs special treatment to organize in appropriate format
  if(assay != "gene_expression_files"){
    original_view <- assay != "mbaa"
    dat <- con$getDataset(assay, 
                          original_view = original_view, 
                          transformMethod = "auto", 
                          colFilter = pidsFilt)
  }else{
    # Use filteredPids to only download matrices for specified studies and then
    # subset data by filtered gef to ensure only correct pids picked up.
    tmp <- strsplit(filteredPids, ";")
    tmp <- lapply(tmp, strsplit, split = "\\.")[[1]]
    sdys <- paste0("SDY", unique(sapply(tmp, "[", 2)))
    mats <- con$cache$GE_matrices$name[ con$cache$GE_matrices$folder %in% sdys ]
    eset <- con$getGEMatrix(mats)
    dat <- data.frame(t(Biobase::exprs(eset)),stringsAsFactors = FALSE)
    gef <- con$getDataset("gene_expression_files", 
                          original_view = TRUE, 
                          colFilter = pidsFilt)
    dat <- dat[ rownames(dat) %in% gef$biosample_accession, ]
    matchOrder <- match(rownames(dat), gef$biosample_accession)
    dat$study_time_collected <- gef$study_time_collected[ matchOrder ]
    dat$study_time_collected_unit <- gef$study_time_collected_unit[ matchOrder]
    ptid <- gef$participant_id[ matchOrder ]
    if(aggregateBy == "subject-tp"){
      dat$sub_tp <- paste0( ptid, "_", dat$study_time_collected)
    }else{
      dat$participant_id <- ptid
    }
  }

  # Update stc_key to use underscore and replace negative sign for later use in colnames
  dat$stc_key <- paste(dat$study_time_collected, dat$study_time_collected_unit, sep = "_")
  dat <- dat[ dat$stc_key %in% gsub(" ", "_", timePts), ]
  dat$stc_key <- gsub("-", "neg", dat$stc_key)
  
  # Avoid downstream errors by returning NULL if assay does not contain chosen timepoints
  if(nrow(dat) == 0){ return() } 
  
  # Add biosample_accession column if not present
  if (projLvl) {
    if (!"biosample_accession" %in% names(dat)) {
      dat$biosample_accession <- rownames(dat)
    }
  }
  
  # Transform assay data to be in following format depending on aggregateBy var:
  # subject-tp: rownames are sub_tp and colnames are grouping variable for value reported
  # subject: rownames are participant_id and colnames are grouping var concat with stc_key
  
  # ---------------- HAI, NAb ----------------- #
  # Grouping by pid instead of pid * virus, otherwise same mechanics as other assays
  if(assay %in% c("hai","neut_ab_titer")){
    dat$value_reported <- as.numeric(dat$value_reported)
    dat <- dat[, lapply(.SD, mean), .(participant_id, stc_key), .SDcols = c("value_reported")]
    sum_col <- paste0("mean_", assay)
    setnames(dat, "value_reported", sum_col)
    if(aggregateBy == "subject-tp"){
      dat$sub_tp <- paste(dat$participant_id, dat$stc_key, sep = "_")
      dat <- dat[ , grep("sub|mean", colnames(dat)), with = FALSE]
    }else{
      dat <- spread(dat, key = "stc_key", value = sum_col)
      nms <- grep("participant_id", colnames(dat), value = TRUE, invert = TRUE)
      setnames(dat, nms, paste0(nms, "_", sum_col))
    }

  # ---- ELISA, ELISPOT, MBAA, PCR, FCS  ------ #
  }else if(assay %in% c("elisa", "elispot", "mbaa", "pcr", "fcs_analyzed_result")){
    valCol <- switch( assay,
          "elisa" = "value_preferred",
          "elispot" = "spot_number_reported",
          "mbaa" = "concentration_value",
          "pcr" = "value_reported",
          "fcs_analyzed_result" = "population_cell_number"
        )
    grpByCol <- switch( assay,
          "elisa" = "analyte",
          "elispot" = "analyte",
          "mbaa" = "analyte",
          "pcr" = "gene_symbol",
          "fcs_analyzed_result" = "population_definition_reported"
        )
    dat[[valCol]] <- as.numeric(dat[[valCol]]) # some assays seem to have issues with types
    keepCols <- c("participant_id", "stc_key", grpByCol, valCol)
    dat <- dat[ , keepCols, with = FALSE ]
    if(aggregateBy == "subject-tp"){
      dat <- dat[, sub_tp := paste(participant_id, stc_key, sep = "_")]
      byCols <- c("sub_tp", grpByCol)
      keyCol <- grpByCol
    }else{
      dat <- dat[, grpByColDay := paste(dat[[grpByCol]], stc_key, sep = "_")]
      byCols <- c("participant_id","grpByColDay")
      keyCol <- "grpByColDay"
    }
    dat <- dat[, lapply(.SD, mean), by = byCols, .SDcols = c(valCol)]
    dat <- spread(dat, key = keyCol, value = valCol)
    
  # ------ Gene Expression -------------- #
  }else if(assay == "gene_expression_files"){
    # Be sure to only subset by GE timepoints not all assay time points!
    geOnlyTp <- unique(dat$stc_key)

    
    
    # Reorganize matrices by gs_timePt as colnames and cbind
    if( aggregateBy == "subject" ){
      
      # Figure out subs with all tp
      subTps <- vapply(unique(dat$participant_id), 
                       function(x){list(unique(dat$stc_key[ dat$participant_id == x]))},
                       FUN.VALUE = list(c("6_hours", "12_hours")))
      goodSubs <- vapply(names(subTps), 
                         function(x){all(geOnlyTp %in% subTps[[x]])}, 
                         FUN.VALUE = TRUE)
      goodSubs <- names(goodSubs)[goodSubs]
      
      mats <- lapply(geOnlyTp, function(x){
        mat <- dat[ dat$stc_key == x & dat$participant_id %in% goodSubs, ]
        mat <- mat[, grep("stc_key|study_time_collected", colnames(dat), invert = T)]
        nms <- colnames(mat)[ !colnames(mat) %in% c("participant_id", "biosample_accession") ]
        nms <- paste0(nms, "_", gsub(" Days", "", x))
        colnames(mat) <- c(nms, "participant_id", "biosample_accession")
        
        # Aggregate technical replicates
        subCounts <- table(mat$participant_id)
        if (any(subCounts > 1)) {
          # This creates a matrix with a column for each participant and a row for each feature
          meanMatrix <- vapply(names(subCounts), function(sub) {
            subset <- mat[mat$participant_id == sub,]
            meanValues <- colMeans(subset[,-grep("participant_id|biosample_accession", colnames(subset))], na.rm = TRUE)
            meanValues
          }, 
          FUN.VALUE = numeric(ncol(mat) -1),
          USE.NAMES = TRUE)
          
          # Get it back in the right format
          meanMatrix <- as.data.frame(t(meanMatrix))
          meanMatrix$participant_id <- rownames(meanMatrix)
          mat <- meanMatrix
        }
        
        mat <- mat[ order(match(mat$participant_id, goodSubs)), ]
        mat <- mat[ , -grep("participant_id", colnames(mat)) ]
        
        return(mat)
      })
      dat <- Reduce(function(x,y){ cbind(x,y) }, mats)
      dat$participant_id <- goodSubs
    }else{
      # Aggregate technical replicates
      subCounts <- table(dat$sub_tp)
      if (any(subCounts > 1)) {
        # This creates a matrix with a column for each participant and a row for each feature
        meanMatrix <- vapply(names(subCounts), function(sub) {
          subset <- dat[dat$sub_tp == sub,]
          meanValues <- colMeans(subset[,-grep("sub_tp|study_time_collected|stc", colnames(subset))], na.rm = TRUE)
          meanValues
        }, 
        FUN.VALUE = numeric(ncol(dat) -4),
        USE.NAMES = TRUE)
        
        # Get it back in the right format
        meanMatrix <- as.data.frame(t(meanMatrix))
        meanMatrix$sub_tp <- rownames(meanMatrix)
        dat <- meanMatrix
      } else {
        dat <- dat[, grep("stc_key|study_time_collected", colnames(dat), invert = T)]
      }
    }
  }

  return(data.frame(dat, stringsAsFactors = FALSE))
}
```

```{r prep-assay-data, results = 'hide'}
# Pulling labkey.url.base and labkey.url.path from injected code and using this
# to set up connection
con <- CreateConnection()

# get assay data
# NOTES:
# 1. When aggregateBy == "subject", GE data is subset to subjects with all timepoints
# Otherwise too much imputation is done and would affect subjects score.
# 2. If impute == "none", then assay data matrix is cut down to only subjects with
# every assay * timepoint combination. This could be highly limiting in project level work.
# 3. When there are multiple records for a subject at a timepoint, they are aggregated by mean. 
aData <- lapply(assays,
                getAssayData,
                con = con,
                pidsFilt = pidsFilt,
                filteredPids = filteredPids,
                timePts = timePts,
                aggregateBy = aggregateBy)
names(aData) <- assays

# Check aData to be sure non-null
nulls <- sapply(aData, is.null)
aData <- aData[ !nulls ]

# Impute missing values within each assay on per sample or sample_tp (column) basis if selected by user
# Get number of observations to be imputed
if ( impute != "none" ) {
  # Get subjects with missing feature data
  missingFeaturesBySubject <- lapply(aData, function(df){
    rownames(df) <- df$participant_id
    apply(df, 1, function(x)sum(is.na(x)))
  })
  
  missingFeaturesDT <- data.table(subject = names(unlist(missingFeaturesBySubject)),
                                missing = unlist(missingFeaturesBySubject))
  missing <- missingFeaturesDT[, .(missing = sum(missing)), subject]
  missingFeaturesBySubject <- missing$missing
  names(missingFeaturesBySubject) <- missing$subject

  missingSubjectsByFeature <- lapply(aData, function(df) {
    apply(df, 2, function(x)(sum(is.na(x))))
  })
}

if(impute == "mean" | impute == "median"){
  fn <- get(impute)
  aData <- lapply(aData, function(df){
    df <- apply(df, 2, function(x){
      if( !grepl("SUB", x[[1]])){
        x <- as.numeric(x)
        x[ is.na(x) ] <- fn(x, na.rm = TRUE)
      }
      return(x)
    })l
  })
}else if(impute == "knn"){
  library(impute)
  # For impute.knn, data should be "An expression matrix
  # with genes in rows, samples in columns"

  aData <- lapply(aData, function(df){ 
    # Transform into correct format
    if ("participant_id" %in% names(df)) {
      participant_ids <- df$participant_id
      df <- df[-which(names(df) == "participant_id")]
    }
    mat <- t(df)
    
    # Impute
    res <- impute::impute.knn(as.matrix(mat))
    
    # Transform back
    res_df <- as.data.frame(t(res$data), stringsAsFactors = FALSE)
    res_df$participant_id <- participant_ids 

    return(res_df)
  })
}else if(impute == "none"){
  aData <- lapply(aData, function(df){ 
    df <- df[ complete.cases(df), ]
  })
  prbAssays <- sapply(aData, function(x){ return(dim(x)[[1]] == 0 )} )
  prbAssays <- assays[ prbAssays ]
  if (length(prbAssays) > 0 ) {
    prbAssays <- sapply(prbAssays, function(x){ 
      x <- switch(x,
          "elisa" = "Elisa",
          "elispot" = "Elispot",
          "mbaa" = "MBAA",
          "pcr" = "PCR",
          "fcs_analyzed_result" = "Flow Cytometry",
          "gene_expression_files" = "Gene Expression",
          "hai" = "HAI",
          "neut_ab_titer" = "Neutralizing Antibody Titer"
        )
    })
    stop(paste0("R Report Error: Some assays do not have any subjects with complete cases. Select an imputation method or remove problematic assays (", paste(prbAssays, collapse = ", "), ")."))
  }
}

# Find subs with all datasets
subs <- sapply(aData, function(x){
  x[, grep("sub_tp|participant_id", colnames(x))]
})
numSubs <- table(unlist(subs))
subs <- names(numSubs)[ numSubs == length(aData) ]

if(length(subs) < 2){
  stop("R Report Error: Fewer than two subjects available for analysis across all assays. Select imputation method other than 'None' and retry.")
}

if (impute != "none") {
  # Subset imputation info to only included subjects
  missingFeaturesBySubject <- missingFeaturesBySubject[subs]
}

# Remove subs without all datasets and order for cbind
aData <- lapply(aData, function(x){
  x <- data.frame(x, stringsAsFactors = FALSE) # imputation may change class
  nmsCol <- grep("sub_tp|participant_id", colnames(x), value = T)
  x <- x[ x[[nmsCol]] %in% subs, ]
  x <- x[ order(match(x[[nmsCol]], subs)), ]
  x <- x[, -grep(nmsCol, colnames(x)), drop = FALSE ] # ensure remains df in case only one feature
})

# combine
allMat <- Reduce(function(x,y){cbind(x,y)}, aData)
rownames(allMat) <- subs

# normalize after ensuring numeric
allMat <- scale(apply(allMat, 2, as.numeric))

# remove any features that have no variance
noVariance <- apply(allMat, 2, function(x){ return(length(unique(x)) == 1)})
allMat <- allMat[ , !noVariance, drop = FALSE ]

if( is.null(dim(allMat)) || dim(allMat)[2] < 2){
  stop("R Report Error: Too few variables selected. Please select more assays or timepoints and re-run.")
}
```


```{r prep-demo-data}
# Get demographic data and add cohort name
demo <- con$getDataset("demographics", colFilter = pidsFilt)

if (impute != "none") {
  # Add number of of imputed features to demo
  demo$imputed_values <- missingFeaturesBySubject[demo$participant_id]
}
# cohortMap <- Rlabkey::labkey.selectRows(baseUrl = con$config$labkey.url.base,
#                                         folderPath = con$config$labkey.url.path,
#                                         schemaName = "study",
#                                         queryName = "cohort",
#                                         showHidden = TRUE,
#                                         colFilter = pidsFilt)
# demo$cohort <- cohortMap$Label[ match(demo$cohort, cohortMap$Rowid) ]
```



```{r add-project-data, eval = projLvl}
# If project level, add additional metadata for labelling points
# --- Cell type ---
dimSample <- data.table(Rlabkey::labkey.selectRows(baseUrl = labkey.url.base,
                                          folderPath = labkey.url.path,
                                          schemaName = "immport", 
                                          queryName = "dimsample",
                                          colNameOpt = "fieldname"))
setnames(dimSample, "type", "sample_type")
# One row per participant
sampleTypes <- dimSample[subjectid %in% dat$participant_id]
sampleTypes <- dimSample[, unique(cellType), ]

# FAS name

# FAS vendor

# Immune Exposure

# Immune Exposure type

```

## Parameters
- **Timepoints**: `r timePts`
- **Assays**: `r assays`
- **Time As**: `r aggregateBy`
- **Plot Type**: `r plotType`
- **Number of Components Analyzed**: `r numComponents`
- **Imputation Method**: `r impute`
- **Immune Response Label**: `r responseVar`

## General Information
Note: Only subjects with assay data at all timepoints are included in the final
dimension reduction analysis. By default, there is no imputation. If you do select
to impute data, it is done within the individual assay data prior to combining multiple
assays.  For gene-expression data, imputation only occurs if subjects have at least
partial data for the timepoint. For non-gene-expression data, imputation does not require
partial data for the timepoint (e.g. some hai strains but not others).

- **Number of Observations (Subjects)**: `r dim(allMat)[1]`
- **Number of Observations Removed due to missing data**: `r length(numSubs[ numSubs < length(aData)])`
- **Number of Features Used (Assay Data)**: `r dim(allMat)[2]`
- **Number of Features Removed Due to Lack of Variance**: `r sum(noVariance)`


`r if ( impute != "none" ) {paste0("- **Number of Observations with imputed values**: ", sum(missingFeaturesBySubject > 0))}`
`r if ( impute != "none" ) {paste0("- **Total Number of Imputed Values**: ", sum(missingFeaturesBySubject))}`


```{r plot helpers}
# helper for iterating through multiple components
genPlot <- function(i, j, resObj, type, prettyLbl, colorCol){
  if(type == "tSNE"){
    df <- data.frame(x = resObj$Y[,i],
                     y = resObj$Y[,j],
                     stringsAsFactors = FALSE)
  }else{
    df <- data.frame(x = resObj$x[, paste0("PC",i)],
                     y = resObj$x[, paste0("PC",j)],
                     stringsAsFactors = FALSE)
  }

  p <- plot_ly(data = df,
               x = ~x,
               y = ~y,
               type = "scatter",
               mode = "markers",
               marker = list(size = 14),
               color = colorCol,
               hoverinfo = 'text',
               text = paste(prettyLbl, ": ", colorCol, "<br>ID: ", subs)) %>%
    layout(xaxis = list(title = paste0(type, i)),
           yaxis = list(title = paste0(type, j)),
           annotations = list(yref = 'paper',
                              xref = 'paper',
                              y = 1.02,
                              x = 1.175,
                              text = prettyLbl,
                              showarrow = FALSE),
           autosize = T,
           width = 700,
           showlegend=TRUE)
}

makePlot <- function(label, aggregateBy, demo, numComponents, plotType, allMat){
  prettyLbl <- tools::toTitleCase(gsub("_", " ", label))

  if(label == "time"){
    colorCol <- gsub("^SUB\\d{5,6}\\.\\d{2,4}_", "", subs)
  }else if(label == "study"){
    colorCol <- gsub("^SUB\\d{5,6}\\.", "", subs)
    colorCol <- paste0("SDY", gsub("_\\d+$", "", colorCol))
  }else if(label %in% c("hai", "neut_ab_titer")){
    re <- re[participant_id %in% subs ]
    # create response value from fold-change compared to baseline for each virus
    re <- re[, list(arm_accession, study_time_collected, study_time_collected_unit,
                    response = value_reported/mean(value_reported[study_time_collected<=0])),
             by = "virus,participant_id"]
    # determine mean response for each study day across virus
    re <- re[, mr := mean(response, na.rm=T), by = "study_time_collected"]
    # determine maximum mean response for each cohort for each study day
    re <- re[, ma := max(mr, na.rm=T), by = "arm_accession"]
    # Determine the peak study day for each cohort
    peak <- unique(re[mr == ma, list(study_time_collected, arm_accession)])
    # Use merge to filter to study days for peak response by cohort
    re <- merge(re, peak, by=c("study_time_collected", "arm_accession"))
    # provide single response for each participant by taking the log of max
    re <- re[, list(response = log2(max(response))), by = "participant_id"]
    # Dichotomize the participants into high and low responders arbitrarily at log2(4)
    # based on default values in IRP
    re <- re[, response := ifelse(response >= log2(4), "high responder",  "low responder")]
    colorCol <- re$response[order(match(subs, re$participant_id))]
  }else{
    if(aggregateBy == "subject-tp"){ subs <- gsub("_.+", "", subs) }
    colorCol <- demo[[label]][ match(subs, demo$participant_id)]
  }
  # create and sort possible component combinations
  poss <- expand.grid(j = 1:numComponents, i = 1:numComponents)
  poss <- poss[ poss$j != poss$i, ]
  poss$test <- sapply(1:nrow(poss), function(x){
    paste(sort(c(poss[x,1], poss[x,2])), collapse = ":")
  })
  poss <- poss[ !duplicated(poss$test), ]

  # Run analysis and get pieces together for plotting
  if(plotType == "tSNE"){
    # perplexity * 2 < nrow(x) - 1
    if (perplexity > (nrow(allMat) - 1)/3) {
      minPerplexity <- floor((nrow(allMat) - 1)/3)
      stop(paste0("R Report Error: Perplexity is too large for the number of samples. Select perplexity <= ", minPerplexity))
    }
    set.seed(8)
    # Avoid duplicate rows by adding random noise
    if( any(duplicated(allMat)) ){
      allMat[,1] <- jitter(allMat[,1], factor = 1, amount = NULL)
    }
    tRes <- Rtsne::Rtsne(allMat, dims = numComponents, perplexity = perplexity)
    moreArgs <- list(resObj = tRes, type = "tSNE", prettyLbl = prettyLbl, colorCol = colorCol)
  }else{
    pca <- prcomp(allMat)
    moreArgs <- list(resObj = pca, type = "PCA", prettyLbl = prettyLbl, colorCol = colorCol)
  }

  plots <- mapply(genPlot,
                  i = poss$i,
                  j = poss$j,
                  MoreArgs = moreArgs,
                  SIMPLIFY = FALSE
  )
}
```

## Plots {.tabset .tabset-fade .tabset-dropdown} 

### Age
```{r  age, fig.align="left"}
plots <- makePlot(label = "age_reported",
                  aggregateBy = aggregateBy,
                  demo = demo,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```

### Gender
```{r  gender, fig.align="left"}
plots <- makePlot(label = "gender",
                  aggregateBy = aggregateBy,
                  demo = demo,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```

### Ethnicity
```{r  ethnicity, fig.align="left"}
plots <- makePlot(label = "ethnicity",
                  aggregateBy = aggregateBy,
                  demo = demo,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```

### Race
```{r  race, fig.align="left"}
plots <- makePlot(label = "race",
                  aggregateBy = aggregateBy,
                  demo = demo,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```

### Cohort
```{r  cohort, fig.align="left"}
plots <- makePlot(label = "cohort",
                  aggregateBy = aggregateBy,
                  demo = demo,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```

```{r showTime}
showTime <- aggregateBy == "subject-tp"
```

`r if (showTime) {"### Timepoint"}`
```{r  timePt, fig.align="left", eval = showTime}
plots <- makePlot(label = "time",
                  aggregateBy = aggregateBy,
                  demo = demo,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```

`r if (projLvl) {"### Study"}`
```{r  byStudy, fig.align="left", eval = projLvl}
  plots <- makePlot(label = "study",
                    aggregateBy = aggregateBy,
                    demo = demo,
                    numComponents = numComponents,
                    plotType = plotType,
                    allMat = allMat
  )
  htmltools::tagList(plots)
```

```{r IRcondition}
re <- tryCatch(
  con$getdataset(responseVar, original_view = TRUE),
  warning = function(w) return(w),
  error = function(e) return(e)
)
IRcondition <- is.null(re$message)
```

`r if (IRcondition) {"### Immune Response"}`
`r if (IRcondition) {"Note: Not all subjects may have immune repsonse data"}`

```{r IR, fig.align="left", eval = IRcondition}
re <- tryCatch(
  con$getDataset(responseVar, original_view = T),
  warning = function(w) return(w),
  error = function(e) return(e)
)
if(is.null(re$message)){
  plots <- makePlot(label = responseVar,
                    aggregateBy = aggregateBy,
                    demo = demo,
                    numComponents = numComponents,
                    plotType = plotType,
                    allMat = allMat
  )
  htmltools::tagList(plots)
}else{
  cat(paste0("Response variable ", responseVar, " returns empty data frame from study.  Data is not available for given participants."))
}
```

```{r imputeCondition}
imputed <- impute != "none"
```
`r if (imputed) {"### Imputed Values"}`
```{r Imputed, fig.align="left", eval = imputed}
plots <- makePlot(label = "imputed_values",
                  aggregateBy = aggregateBy,
                  demo = demo,
                  numComponents = numComponents,
                  plotType = plotType,
                  allMat = allMat
)
htmltools::tagList(plots)
```



<script>
window.HTMLWidgets.staticRender();
</script>

