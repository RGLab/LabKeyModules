# Automated Gating and Visualization of Cytometry Time of Flight (CyTOF) Data
### Report generated by `r labkey.user.email`

## Summary
This report performs automated gating of CyTOF data from the study <a href="http://www.ncbi.nlm.nih.gov/pubmed/22265676" target="_blank">(Cytometry by time-of-flight shows combinatorial cytokine expression and virus-specific cell niches within a continuum of CD8+ T cell phenotypes.)</a> using the [openCyto framework](http://www.bioconductor.org/packages/2.14/bioc/html/openCyto.html). We identify Naive, Effector, Effector Memory and Central Memory T-cells and map these onto the first three principal components of the data, which can be visualized using *webGL*.

```{r knitr-opts, echo = FALSE, message = FALSE}
library(knitr)
opts_knit$set(progress = TRUE, verbose = TRUE)
opts_chunk$set(cache=FALSE, cache.path=file.path(labkey.file.root, "cache/CyTOF_PCA/", labkey.user.email, ""))
opts_chunk$set(echo=FALSE, eval=TRUE, message=TRUE, warning=FALSE, error=TRUE, dev="png",
               fig.height=6, fig.with=4, dpi=100, fig.align="center")
options(width=80)
```

```{r setup, echo=FALSE, warning=TRUE, message=FALSE}
library(flowCore)
library(flowViz)
library(flowWorkspace)
library(data.table)
library(reshape2)
library(plyr)
library(openCyto)
library(flowClust)
library(mvtnorm)
library(rgl)
library(FactoMineR)
knit_hooks$set(webgl=rgl::hook_webgl)
```

```{r webgl,results='asis'}
cat('<script type="text/javascript">', readLines(system.file('htmlwidgets/lib/CanvasMatrix', 'CanvasMatrix.src.js', package = 'rgl', mustWork=TRUE)), '</script>', sep = '\n')
```

```{r params,echo=FALSE}
if( 'regate' %in% names(labkey.url.params)){
   regate<-get("regate",labkey.url.params)
   if(regate%in%c("FALSE","TRUE")){
        regate<-as.logical(regate)
   }else{
    regate<-FALSE
   }
}else{
   regate<-FALSE
}
```
   
```{r custom_gating_functions,echo=FALSE,warning=FALSE,message=FALSE}
    
#Custom Gating Functions for CyTOF
boundry <-  function(xs) {
    # find the boundry events that are above a quantile and below a line 

    cxs <- scale(xs) # scale data so that it can be compaired to the results from qnorm
    f <- qnorm(0.95) # set a boundry level
    pd <- dmvnorm(c(f, f))[1] # and find the p(x) for that level

    pxs <- dmvnorm(x=cxs)  
    idxs <- (pxs > pd) # find those points who are above the boundy level

    idxs2 <- ((-1*cxs[,1]) + 1.96) > cxs[,2] # find points that are below the line with y=-1*x+b 
    pos_xs <- xs[idxs&idxs2,] # intersection of points below line and above threshold level
 
    hpts <- chull(pos_xs) # find the boundry points of the intersection of cells
    return(pos_xs[hpts,])
}

.dnaGate <- function(fr, pp_res, channels=NA, filterId="", ...){ 
    xs <- exprs(fr[,c(channels)]) # extract just the parameter values being inspected
    pnts <- boundry(xs) # find the verticies of the gate
    return(polygonGate(.gate=pnts, filterId=filterId))
}

out <- capture.output(suppressMessages(openCyto::registerPlugins(fun=.dnaGate,methodName='dnaGate', dep='mvtnorm')))
```
   
```{r load_data, echo=FALSE, cache=TRUE, echo=FALSE}
       dt<-data.table(labkey.data)
       setnames(dt,tolower(colnames(dt)))
       path <- paste0(labkey.file.root, "/")
       rawdata_path <- gsub("@files", "@files/rawdata/flow_cytometry/", labkey.file.root)
       dt=dt[,link:=paste0(rawdata_path,file_info_name)]
     
#Grab a list of all the FCS files
fcsfiles<-as.character(dt$link)
 
#Read the CyTof data into separate flowFrames
frames<-vector('list',length(fcsfiles))
for(i in seq_along(frames)){
    suppressWarnings(frames[[i]]<-read.FCS(fcsfiles[i]))
}
names(frames)<-as.character(fcsfiles)

#get some information about the size and dimension of each file
fileinfo<-data.frame(dt,filename=as.character(fcsfiles),cells=do.call(c,lapply(frames,nrow)),dims=do.call(c,lapply(frames,ncol)))
```

   
```{r construct_flowsets, cache=TRUE, echo=FALSE}
#construct flowsets for matching files and correct some marker names
fs<-dlply(fileinfo,.(dims),function(x)with(x,flowSet(frames[as.character(filename)])))
```
   
```{r transform_data,cache=TRUE,echo=FALSE}   
#transform the data
fs[[1]] <- transformList(colnames(fs[[1]])[-1],list(asinh))%on%fs[[1]]
```
          
```{r annotate,echo=FALSE,cache=TRUE}
#reorder the fileinfo to match the flowset
fileinfo<-fileinfo[match(c(sampleNames(fs[[1]]),sampleNames(fs[[2]])),as.character(fileinfo$filename)),]

# load the phenodata and set the 'name' column to match the sampleNames
setnames(fileinfo,"filename","name")
fileinfo<-data.table(fileinfo)
fileinfo=fileinfo[,name:=as.character(name)]
```
          
```{r construct_gating_sets,cache=FALSE,message=FALSE}
#Construct a gating set from the flow data
if(file.exists(paste0(path,"analysis/gating_set"))){
    suppressMessages(gs<-load_gs(paste0(path,"analysis/gating_set")))
}else{
    suppressMessages(gs<-GatingSet(fs[[1]]))
    pd <- as.data.frame( fileinfo[1:length(gs),] );
    rownames( pd ) <- pd[ , 'name' ]; 
    pData( gs ) <- pd;
    cat('Saving ungated data\n');
    save_gs(gs,path=paste0(path,"analysis/gating_set"))
}          
```

```{r filter,echo=FALSE}
include<-fileinfo$name[fileinfo$name%like%"PI"&fileinfo$dims==48&fileinfo$cells>20000]
if("subject" %in% names(labkey.url.params)){
   subject <- as.numeric(labkey.url.params$subject)
   if(is.na(subject)){
       subject <- 1
   }
   if(subject<1 || subject>length(include)){
    subject<-1
   }
}else{
   subject<-1
}
```
## Automated Gating   
We load a gating template definition for the CyTOF panel used in this study into openCyto.

```{r templates, echo=FALSE, cache=FALSE, message=FALSE}
#load gating template
capture.output(template<-gatingTemplate(list.files(path=paste0(path, "analysis/"),pattern="csv",full=TRUE)),file="/dev/null")
fd<-flowData(gs)
colnames(fd)<-c("Time","Cell_length","DNA1","DNA2","CD3","CD3(Cd108)Dd","CD3(Cd110)Dd",
"CD3(Cd111)Dd",      "CD3(Cd112)Dd",      "CD3(Cd113)Dd",      "CD3(Cd114)Dd",
"CD3(Cd116)Dd",     "LiveDead" ,"Ba138(Ba138)Dd"  ,  "MuCD45" ,  "IL2"  , 
"CCR7"  ,   "CD7(Nd143)Dd"    , 
"CD45RO"  , "CD57"   ,  "CD8(Nd146)Dd"    ,  "CD11a(Nd148)Dd"   , "MIP1b"   , "CD69(Sm149)Dd"    ,
"TNFa"   ,  "CD27"   ,  "GzmB"   ,  "CD107" , "Tet156(Gd156)Dd"  , "157blank(Gd157)Dd",
"Tet158(Gd158)Dd" ,  "CD28"   ,  "Tet159(Tb159)Dd" ,  "Tet165(Ho165)Dd" ,  "CD45RA"  , "CD43(Er167)Dd"    ,
"Tet168(Er168)Dd"  , "IFNgamma" ,"CD62L"  ,  "HLADR(Yb171)Dd"  ,  "CD49d(Yb172)Dd"  ,  "blank173(Yb173)Dd",
"KLRG1"   , "MIP1a"   , "Perforin" ,"GMCSF" ,   "CD29(Dy162)Dd"   ,  "Tet164(Dy164)Dd" )
flowData(gs)<-fd
```
The data is gated by applying the template to the data set. Gate coordinates are derived in a data-driven manner for each sample.  
   
```{r gating, echo=FALSE,eval=TRUE,message=FALSE,warning=FALSE,cache=FALSE}
if ( file.exists( paste0( path,"analysis/gating_set_gated" ) ) && !regate ){
    gs<-load_gs(paste0(path,"analysis/gating_set_gated"))
} else{
    gs<-gs[include]
    cat("Gating\n")
    gating(template,gs)

    if ( file.exists( paste0( path, 'analysis/gating_set_gated' ) ) ){
        res <- unlink( paste0(path,"analysis/gating_set_gated"), force = T, recursive = T );
        if ( res != 0 ){
            stop( 'Removal of the existing gated gating set from the file system failed' );
        }
    }
    cat("Saving gated data\n")
    save_gs(gs,path=paste0(path,"analysis/gating_set_gated"),overwrite=TRUE)
}
```

```{r pcaplot,echo=FALSE}
.pcaPlot<-function(i,size){
   ii<-include[i]
    cn<-colnames(flowData(gs[[ii]]))
    target_pops<-flowSet(getData(gs[[ii]],"TN"),getData(gs[[ii]],"TCM"),getData(gs[[ii]],"TEM"),getData(gs[[ii]],"TEF"))
    topca<-fsApply(target_pops,exprs)[,getNodes(gs[[ii]],path="auto")[c(9,10,11,12,13,14,15,16,17,18,19)]]
    #topca<-fsApply(target_pops,exprs)
    colors<-rep(1:4,as.vector(fsApply(target_pops,nrow)))
    pr<-PCA(topca,graph=FALSE)
    plot3d(pr$ind$coord,col=colors,xlab="PC1",ylab="PC2",zlab="PC3",type="s",size=size,box=F)
}
          

```

## Visualization  
A selected sample is visualized in 3-D using *webGL* technology. Individual points represent individual cell events. Colors represent different T-cell subsets.
<script>
    jQuery( document ).ready( function(){
        jQuery('#filesFCS').attr( 'action', '/project' + LABKEY.container.parentPath + '/' + LABKEY.container.title + '/begin.view?' );
    });
</script>
<form id="filesFCS" method="GET">
<select name="subject">
```{r results='asis'}
cat(
    paste0(
        lapply( 1:length(include), function( e ){
            return( paste0( '<option ', if (e == subject){ 'selected="selected"' }, ' value="', e, '">', basename( include[ e ] ), '</option>' ) )
        }),
        collapse=''
    )
)
```
</select>
    <input type="hidden" name="pageId" value="Visualization">
    <input type="hidden" name="regate" value="FALSE">
    <input type="submit" value="View">
</form>

Viewing: `r basename(include[subject])`  

Black: Naive  
Central Memory: Red  
Effector Memory: Green  
Effector: Blue
                 
```{r plot3d,echo=FALSE,eval=TRUE,webgl=TRUE,cache=FALSE}
.pcaPlot(subject,size=0.5)
```

<style type="text/css">
#plot3dcanvas {
    border: 1px black solid;
}
</style>

